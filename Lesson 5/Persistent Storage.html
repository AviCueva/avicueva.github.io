
<!-- saved from url=(0063)http://courses.oreillyschool.com/Python2/PersistentStorage.html -->
<html><!-- Copyright (c) 1998-2014 O'Reilly Media, Inc.
			This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
			See http://creativecommons.org/licenses/by-sa/3.0/legalcode for more information.
            --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="./Persistent Storage_files/Lab.css"><script async="" src="./Persistent Storage_files/analytics.js"></script><script type="text/javascript" src="./Persistent Storage_files/Lab.js"></script><script language="javascript"></script><title>Persistent Storage</title></head><body id="body" style="font-size: 12px;"><a name="top"></a><div class="title">Persistent Storage</div><div class="resize"><a href="http://courses.oreillyschool.com/Python2/PersistentStorage.html#top" onclick="changeSize(&#39;smaller&#39;);" class="aS" title="Keep clicking to make fonts smaller">A</a><a href="http://courses.oreillyschool.com/Python2/PersistentStorage.html#top" onclick="changeSize(&#39;larger&#39;);" class="aL" title="Keep clikcing to make fonts larger">A</a><a href="http://courses.oreillyschool.com/Python2/PersistentStorage.html#top" onclick="lv()" class="lv" title="Adjust Page for High Contrast">HC</a><div id="fh"><p>Click on <span class="aS">A</span> to make all fonts on the page smaller.</p><p>Click on <span class="aL">A</span> to make all fonts on the page larger.</p><p>Click on <span class="lv">HC</span> to toggle high contrast mode. When you move your mouse over 
                 some bold words in high contrast mode, related words are automatically highlighted. Text is shown
                 in black and white. 
             </p></div></div><hr>
    
    <div class="goalTitle">Lesson Objectives</div><div class="goals">When you complete this lesson, you will be able to:
        
        <ul><li>explain serialization and persistence modules.</li><li>pickle and unpickle various data types.</li><li>update values in a shelf.</li><li>implement the library class.</li><li></li></ul></div><hr>

 <a name="h_01"></a><div class="heading">Persistent Storage</div><div class="headingText"><div class="para">
        
     
        
     <p>Python has modules that let you save Python 
         objects. Saving an object actually takes two steps: serialization and 
         persistence. <i>Serialization</i> (sometimes called marshaling) is the process of converting an 
         object into a stream of bytes. The stream of bytes can be a textual or binary representation of the 
         original object. <i>Persistence</i> means saving that representation to some sort of data store that 
         lives beyond your program's execution time or interactive shell session. Keep in mind that before 
         you <i>persist</i> an object, it must be serialized. In this lesson, we'll explore these object 
         serialization and persistence modules: </p>
     
     <ul><li><a href="http://courses.oreillyschool.com/Python2/PersistentStorage.html#pickle">pickle</a></li><li><a href="http://courses.oreillyschool.com/Python2/PersistentStorage.html#shelve">shelve</a></li><li><a href="http://courses.oreillyschool.com/Python2/PersistentStorage.html#json">json</a></li></ul>
    
 </div></div>
    
 <a href="" name="pickle"></a>
 <a name="h_02"></a><div class="heading">Object Serialization and Persistence Using the pickle Module</div><div class="headingText">
            
        
     <p>Python's <b>pickle</b> module allows you to serialize objects and save them to a file. 
         When using this module, <i>pickling</i> refers to serialization and <i>unpickling</i> refers to 
         deserialization. You can pickle the following data types:</p>
        
     <ul><li>None, True, False</li><li>integers, floating point numbers, complex numbers</li><li>strings, bytes, bytearrays</li><li>tuples, lists, sets, and dictionaries containing only pickleable objects</li><li>built-in functions</li><li>functions defined at the top level of a module (not nested within another class or function)</li><li>classes that are defined at the top level of a module (not nested within another class or function)</li><li>instances of such classes whose __dict__ or __setstate__() is pickleable</li></ul>
     
     
     <p>Let's try using <b>pickle</b>. We'll use 
         pickle's <span class="darkgreen">dump()</span> function to serialize a number of objects and store them to the 
         disk in the first session. 
         Create a <b>PersistentStorage</b> project and assign it to your <b>Python2_Lessons</b> 
             working set.</p>
     <p>In an interactive Python console, type the commands below as shown:</p>
        
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>line1 = ["one", 2, 3.0]</ins>
&gt;&gt;&gt; <ins>line2 = {"dict1": {"random": "stuff"}, "dict2": 2.0}</ins>
&gt;&gt;&gt; <ins>f = open(r"v:\workspace\PersistentStorage\src\pickle1.pkl", 'wb')</ins>
&gt;&gt;&gt; <ins>pickle.dump(line1, f)</ins>
&gt;&gt;&gt; <ins>pickle.dump(line2, f)</ins>
&gt;&gt;&gt; <ins>pickle.dump(None, f)</ins>
&gt;&gt;&gt; <ins>f.close()</ins>
&gt;&gt;&gt;
</pre></div></div>

     <p>In the session above, you created a file (written in binary mode, so that the interpreter wouldn't 
         modify the content) and wrote three objects to it with <span class="darkgreen">pickle.dump()</span>. 
         In each <span class="darkgreen">dump()</span> statement, the first argument is the object to dump, and the second argument is the 
         file to which the serialized version should be written. Now we'll use the 
         <span class="darkgreen">pickle.load()</span> function to read the serialized object back from the file. To 
         demonstrate that the file we just created really is permanent, close your current interactive interpreter 
         console (click the red "Terminate" square <img src="./Persistent Storage_files/icon_terminateconsole.png">) 
         and open a new one for the next part of the exercise. Now, you can be sure that you're seeing exactly what another 
         user would see.</p>
     
     <p><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note">You can also see the <b>pickle1.pkl</b> file we just created in the Package Explorer window. 
         Select the <b>PersistentStorage/src</b> folder and (if necessary) press the <b>F5</b> key to refresh
         the view.</td></tr></tbody></table></p>
     
  <p>In an interactive Python console, type the commands below as shown:</p>

<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>f = open(r"v:\workspace\PersistentStorage\src\pickle1.pkl", 'rb')</ins>
&gt;&gt;&gt; <ins>for i in range(3):</ins>
...     <ins>o = pickle.load(f)</ins>
...     <ins>print(o)</ins>
...
['one', 2, 3.0]
{'dict1': {'random': 'stuff'}, 'dict2': 2.0}
None
&gt;&gt;&gt; <ins>f.close()</ins>
&gt;&gt;&gt;
</pre></div></div>
        
     <p>When you open the files, the 'b' option is appended to the mode to deal with the files in binary 
         mode. This is necessary to ensure that a pickle can be moved from one computer to another with a 
         different architecture (say, from an Intel-based machine to a Power PC). In the 
         fileops example from the previous lesson, you serialized data into a text format, but the pickle 
         module in Python 3 uses a binary format by default. You can take a peek at this format by calling 
         <span class="darkgreen">read()</span> on an open pickle file.</p> 
        
     <p>You can also see from our example that it's possible to pickle several items, one after the 
         other, to a file, and then read them by repeated calls of the <span class="darkgreen">pickle.load()</span> function. If 
         you try to read past the end of the file, <span class="darkgreen">pickle.load()</span> raises an 
         <b>EOFError</b> exception. In an interactive Python console, type the commands below as shown:</p>

<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>open(r"v:\workspace\PersistentStorage\src\pickle1.pkl", 'rb').read()</ins>
b'\x80\x03]q\x00(X\x03\x00\x00\x00oneq\x01K\x02G@\x08\x00\x00\x00\x00\x00\x00e.\x80\x03}q\x00(X\x05\x00\x00\x00dict1q\x01}q\x02X\x03\x00\x00\x00barq\x03X\x03\x00\x00\x00bazq\x04sX\x05\x00\x00\x00dict2q\x05G@\x00\x00\x00\x00\x00\x00\x00u.\x80\x03N.'
&gt;&gt;&gt;
</pre></div></div>

     <p>This binary format is actually pretty compact, especially for more complex data structures. 
         The trade-off is that it's not very human readable. We have omitted some of
         the text to avoid putting a single, very long line in the listing, which would have made it
         even more difficult to read. Unlike your fileops 
         module data, which was easy to understand as text, editing our latest file by hand would be highly impractical. 
         Programs in other languages probably won't be able to read this format, because it's 
         been designed exclusively for Python use. </p>
        
     <p>In fact, some older versions of Python might not be able to read this format. There are actually four 
         different pickle protocols—versions 0 through 3. Version 3 is the default protocol used when 
         pickling an object in Python 3, and it's the one that's currently recommended. You can, however,  
         specify which protocol to use as a third argument to the <span class="darkgreen">dump()</span> function. If 
         you're curious about which formats your version of Python can read, or determining your current default 
         format, that information can be found in the pickle module. More readable information about a 
         pickle file is located in the <b>pickletools</b> module. In an interactive Python console, type the commands below as shown:</p>

<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>import pickletools</ins>
&gt;&gt;&gt; <ins>pickle.format_version</ins>
'4.0'
&gt;&gt;&gt; <ins>pickle.compatible_formats</ins>
['1.0', '1.1', '1.2', '1.3', '2.0', '3.0', '4.0']
&gt;&gt;&gt; <ins>f = open(r"v:\workspace\PersistentStorage\src\pickle1.pkl", 'rb')</ins>
&gt;&gt;&gt; <ins>pickletools.dis(f)</ins>
    0: \x80 PROTO      3
    2: ]    EMPTY_LIST
    3: q    BINPUT     0
    5: (    MARK

    6: X        BINUNICODE 'one'
   14: q        BINPUT     1
   16: K        BININT1    2
   18: G        BINFLOAT   3.0
   27: e        APPENDS    (MARK at 5)
   28: .    STOP
highest protocol among opcodes = 2
&gt;&gt;&gt; <ins>pickletools.dis(f)</ins>
   29: \x80 PROTO      3
   31: }    EMPTY_DICT
   32: q    BINPUT     0
   34: (    MARK
   35: X        BINUNICODE 'dict1'
   45: q        BINPUT     1
   47: }        EMPTY_DICT
   48: q        BINPUT     2
   50: X        BINUNICODE 'random'
   58: q        BINPUT     3
   60: X        BINUNICODE 'stuff'
   68: q        BINPUT     4
   70: s        SETITEM
   71: X        BINUNICODE 'dict2'
   81: q        BINPUT     5
   83: G        BINFLOAT   2.0
   92: u        SETITEMS   (MARK at 34)
   93: .    STOP
highest protocol among opcodes = 2
&gt;&gt;&gt; <ins>pickletools.dis(f)</ins>
   94: \x80 PROTO      3
   96: N    NONE
   97: .    STOP
highest protocol among opcodes = 2
&gt;&gt;&gt;&gt;&gt;&gt; <ins>f.close()</ins>
</pre></div></div>

     <p>In our example, pickle has no problem with native data types. The output 
         from <span class="darkgreen">pickletools.dis()</span> gives us some insight into the way the module stores 
         the data structures, but you don't need to understand serialization format to be able to pickle 
         things. So, what if you wanted to pickle an instance of a class that you wrote? Let's give it a try. In an 
         interactive Python console, type the commands below as shown:</p>
 
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>class Example:</ins>
...     <ins>def __init__(self):</ins>
...         <ins>self.item1 = None</ins>
...     <ins>def item2(self):</ins>
...         <ins>return "instance variable item1 is %s" % (self.item1)</ins>
...
&gt;&gt;&gt; <ins>sample1 = Example()</ins>
&gt;&gt;&gt; <ins>sample1.item1 = "a string"</ins>
&gt;&gt;&gt; <ins>sample1.item2()</ins>
'instance variable item1 is a string'
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'wb')</ins>
&gt;&gt;&gt; <ins>pickle.dump(sample1, f)</ins>
&gt;&gt;&gt; <ins>f.close()</ins>
</pre></div></div>
        
     <p>So far, your <b>sample1.pkl</b> file contains the serialized instance of the 
         <span class="darkred">Example</span> class. </p>
     
     <p><img src="./Persistent Storage_files/icon_terminateconsole.png"> Now, terminate the console session and 
         open a new interactive one (this is important—you don't want the class definition to 
         continue to be available from your previous session) and try unpickling the <span class="darkred">Example</span> 
         instance. In the console, type the commands below as shown: </p>
     
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'rb')</ins>
&gt;&gt;&gt; <ins>sample1 = pickle.load(f)</ins>
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
  File "C:\Python31\lib\pickle.py", line 1356, in load
  encoding=encoding, errors=errors).load()
AttributeError: 'module' object has no attribute 'Example'
&gt;&gt;&gt;
</pre></div></div>
        
     <p>What happened here? You can definitely pickle an object instantiated from your own class, but trying to 
         load your pickled object caused an exception. So, classes that are defined at the top level of a 
         module—that is, classes that are not defined in another class or function—can be pickled. </p>
        
     <p><b>pickle</b> does not include the actual code of the class used to create the instance when serializing 
         an object, it only includes a reference to the class and the module from where it originated. 
        The original module where 
         the class was defined must be exportable into the unpickling environment. </p>
        
     <p>In the listing above, the class <span class="darkred">Example</span> couldn't be found because it was defined in a 
         previous interactive shell session, so <span class="purple">sample1</span> was identified as an instance of class 
         <span class="darkred">__main__.Example</span>. The unpickling module was correctly named 
         <span class="darkblue">"__main__"</span> (as all interactive sessions are), but there was no class 
         <span class="darkred">Example</span> there.</p> 
        
     <p>We'll fix the error by writing the class in a module that can be imported from your interactive shell 
         sessions. To avoid having to tinker with your Python path, create your module and start your  
         interactive shell session in the same path. Everything should work if you create 
         <b>example.py</b> in the <b>PersistentStorage/src</b> directory. Type the code below as shown:</p>
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>class Example:
    def __init__(self):
        self.item1 = None
    def item2(self):
        return "instance variable item1 is %s" % (self.item1)</ins>
</pre></div></div>

     <p>Now you have the <span class="darkred">Example</span> class available in a module. You can  
         use it to create a pickle file in an interactive session. After you've written the pickle file out, 
         you can use <b>pickletools</b> as before to see the class encoded in the file. The module 
         and class names appear together. In an interactive Python console, type the commands below as shown:</p>
        
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>from example import Example</ins>
&gt;&gt;&gt; <ins>obj = Example()</ins>
&gt;&gt;&gt; <ins>obj.item1 = "some text"</ins>
&gt;&gt;&gt; <ins>obj.item2()</ins>
'instance variable item1 is some text'
&gt;&gt;&gt; <ins>obj</ins>
&lt;example.Example object at 0x00E51ED0&gt;
&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'wb')</ins>
&gt;&gt;&gt; <ins>pickle.dump(obj, f)</ins>
&gt;&gt;&gt; <ins>f.close()</ins>
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'rb')</ins>
&gt;&gt;&gt; <ins>import pickletools</ins>
&gt;&gt;&gt; <ins>pickletools.dis(f)</ins>
    0: \x80 PROTO      3
    2: c    GLOBAL     'example Example'
   19: q    BINPUT     0
   21: )    EMPTY_TUPLE
   22: \x81 NEWOBJ
   23: q    BINPUT     1
   25: }    EMPTY_DICT
   26: q    BINPUT     2
   28: X    BINUNICODE 'item1'
   38: q    BINPUT     3
   40: X    BINUNICODE 'some text'
   54: q    BINPUT     4
   56: s    SETITEM
   57: b    BUILD
   58: .    STOP
highest protocol among opcodes = 2
&gt;&gt;&gt;
</pre></div></div>
        
     <p><img src="./Persistent Storage_files/icon_terminateconsole.png"> Again, you'll want to terminate the interactive 
         session and start a new one to make sure that the next session is completely isolated from earlier sessions. 
         In the Python console, type the commands below as shown: </p>
        
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'rb')</ins>
&gt;&gt;&gt; <ins>obj = pickle.load(f)</ins>
&gt;&gt;&gt; <ins>f.close()</ins>
&gt;&gt;&gt; <ins>obj</ins>
&lt;example.Example object at 0x00E51CD0&gt;
&gt;&gt;&gt; <ins>obj.item1</ins>
'some text'
&gt;&gt;&gt; <ins>obj.item2()</ins>
'instance variable item1 is some text'
&gt;&gt;&gt; <ins>import sys</ins>
&gt;&gt;&gt; <ins>sys.modules['example']</ins>
&lt;module 'example' from 'V:\workspace\PersistentStorage\src\example.py'&gt;
&gt;&gt;&gt;
</pre></div></div>

     <p>
         You can see from the value of <b>sys.modules['example']</b> that the <b>example</b>
         module was imported when the class description was unpickled. The
         pickle contains the name of the module from which the class was imported, and the
         interpreter repeats the import to make sure that the required class is available.</p>
     <p>
         Now change the <b>example.py</b> file name to <b>example1.py</b>,
         so it will not be importable under the same name. Do this using
         the context menu—move the cursor over your <b>example.py</b> file in the Pydev
         Package Explorer window, right-click the filename and select
         <b>Refactor | Rename</b>. Enter the new name <b>example1.py</b> and click <b>OK</b>.</p>
     
     <div class="c"><img src="./Persistent Storage_files/RenamingExample.png"></div>
     
     <p>If you repeat the unpickling from the previous session, you will see that it still works,
         despite renaming the file. Type these commands in an interactive Python console:
     </p>
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'rb')</ins>
&gt;&gt;&gt; <ins>obj = pickle.load(f)</ins>
&gt;&gt;&gt;
</pre></div></div>
     
     <p>Why does this still succeed? When a module is imported, the interpreter
         creates a compiled Python file, and even though you have renamed <b>example.py</b>, the
         <b>example.pyc</b> file still exists. This is enough for the interpreter to import the
         <b>example</b> module. You have to make sure that the compiled version of the file under the original name
         is removed. Right-click the <b>PersistentStorage\src</b>
         directory, and select <b>PyDev | Remove *.pyc, *.pyo and *$py.class files</b>. You'll
         have to confirm the actions, after which Ellipse will tell you how many files it has
         deleted (don't worry if there is more than one—the interpreter can recreate these files
         as necessary).</p>
     
     <div class="c"><img src="./Persistent Storage_files/RemoveCompiled.png"></div>
     <p>
         Finally, start another
         new Python console and repeat the unpickling from the last session. 
         In the new interactive Python window, type the commands below as shown:         
     </p>
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'rb')</ins>
&gt;&gt;&gt; <ins>obj = pickle.load(f)</ins><span class="red">
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;

ImportError: No module named 'example'</span>
&gt;&gt;&gt;
</pre></div></div>
     <p>
         The interpreter can no longer unpickle the object, because it cannot locate 
         the module that defines the required class.
     </p>
     <p>So far, we have used functions from the <b>pickle</b> module to handle the pickling and 
         unpickling of objects. The module also defines a <span class="darkred">Pickler</span> class, which lets us 
         create objects. The next example session shows what happens when we 
         try to unpickle too many objects from an <b>Unpickler</b> instance. In an 
         interactive Python console, type the commands below as shown:</p>

<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>            
&gt;&gt;&gt; <ins>import pickle</ins>
&gt;&gt;&gt; <ins>b = ['teeter', 'totter']</ins>
&gt;&gt;&gt; <ins>a = {'mytoy': b}</ins>
&gt;&gt;&gt; <ins>f = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'wb')</ins>
&gt;&gt;&gt; <ins>pickler = pickle.Pickler(f)</ins>
&gt;&gt;&gt; <ins>pickler.dump(a)</ins>
&gt;&gt;&gt; <ins>pickler.dump(b)</ins>
&gt;&gt;&gt; <ins>f.close()</ins>
&gt;&gt;&gt; <ins>ff = open(r'v:\workspace\PersistentStorage\src\sample1.pkl', 'rb')</ins>
&gt;&gt;&gt; <ins>unpickler = pickle.Unpickler(ff)</ins>
&gt;&gt;&gt; <ins>aa = unpickler.load()</ins>
&gt;&gt;&gt; <ins>bb = unpickler.load()</ins>
&gt;&gt;&gt; <ins>aa</ins>
{'mytoy': ['teeter', 'totter']}
&gt;&gt;&gt; <ins>bb</ins>
['teeter', 'totter']
&gt;&gt;&gt; <ins>aa['mytoy'] is b</ins>
False
&gt;&gt;&gt; <ins>extra = unpickler.load()</ins>
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
EOFError: Ran out of input
&gt;&gt;&gt;            
</pre></div></div>

     <p>The <b>Pickler</b> and <b>Unpickler</b> classes are alternatives to calling the 
         <span class="darkgreen">dump()</span> and <span class="darkgreen">load()</span> functions directly from the 
         <b>pickle</b> module. You can instantiate a Pickler object by passing a file object into the 
         Pickler constructor. From there, you can call the instance's own <span class="darkgreen">dump()</span> method 
         to store objects into the same file over and over. The <b>Unpickler</b> class has a corresponding 
         <span class="darkgreen">load()</span> method that unpickles objects from the given file sequentially. When we  
         tried to unpickle more objects than were present in the file, the <b>EOFError</b> was raised.</p>
    
  </div>
    
 <a href="" name="shelve"></a>
 <a name="h_03"></a><div class="heading">The shelve Module</div><div class="headingText">
     
     <p>Using Pickler and Unpickler classes allows us to store multiple objects in a single file. Although 
         pickling individual objects with these classes is fairly straightforward, storing and retrieving 
         multiple objects in one file is not completely documented, and the interface is limited (retrieving 
         objects has to be done sequentially, and there's no obvious way to determine how many objects are pickled). 
         An alternative is to use the <b>shelve</b> module to create a "shelf," which is a
         persistent dictionary of objects.</p>

     <p>You can store objects in a shelf using a key, and then retrieve them with the same key, just like you 
         would with a dictionary. The keys <i>must</i> be encodable as strings—anything else will raise an 
         exception—but the values can be anything that can be pickled (<b>shelve</b> uses pickle as its 
         underlying mechanism for serializing objects). Although it has a good interface for storing and 
         retrieving objects, keep in mind that the shelf contents are stored on disk, not in memory, as
         are <i>copies</i> of the objects.</p>

     <p>To create a shelf object, pass a file name to the <span class="darkgreen">shelve.open()</span> function. If the 
         file doesn't exist, it will be created for you as an empty shelf. The shelf object resulting from the 
         call to <span class="darkgreen">shelve.open()</span> can be used like a dictionary. Use keys to store and 
         retrieve objects. Keys that don't exist will raise an exception. The example below uses the Example 
         class from the example module that you created earlier in this lesson. Make sure you start the 
         interactive shell in the path where that module lives. Before your proceed, rename <b>example1.py</b> back to <b>example.py</b>.
         In an interactive Python console, type the commands below as shown:</p>
     
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>            
&gt;&gt;&gt; <ins>import shelve</ins>
&gt;&gt;&gt; <ins>from example import Example</ins>
&gt;&gt;&gt; <ins>a = [1, 2, 3]</ins>
&gt;&gt;&gt; <ins>b = Example()</ins>
&gt;&gt;&gt; <ins>b.item1 = 'some text'</ins>
&gt;&gt;&gt; <ins>a</ins>
[1, 2, 3]
&gt;&gt;&gt; <ins>b</ins>
&lt;example.Example object at 0x00E677D0&gt;
&gt;&gt;&gt; <ins>b.item2()</ins>
'instance variable item1 is some text'
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf.shlf')</ins>
&gt;&gt;&gt; <ins>shelf['a'] = a</ins>
&gt;&gt;&gt; <ins>shelf['b'] = b</ins>
&gt;&gt;&gt; <ins>shelf.close()</ins>
</pre></div></div>
        
     <p><img src="./Persistent Storage_files/icon_terminateconsole.png"> Terminate the console and start a new one.
         In the new interactive Python console, type the commands below as shown:</p>
     
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import shelve</ins>
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf.shlf')</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
[1, 2, 3]
&gt;&gt;&gt; <ins>shelf['b']</ins>
&lt;example.Example object at 0x00EF14B0&gt;
&gt;&gt;&gt; <ins>shelf['b'].item2()</ins>
'instance variable item1 is some text'
&gt;&gt;&gt; <ins>shelf['z']</ins>
Traceback (most recent call last):
  File "&lt;console&gt;", line 1, in &lt;module&gt;
  File "C:\python\lib\shelve.py", line 112, in __getitem__
    f = BytesIO(self.dict[key.encode(self.keyencoding)])
  File "C:\python\lib\dbm\dumb.py", line 124, in __getitem__
    pos, siz = self._index[key]     # may raise KeyError
KeyError: b'z'
&gt;&gt;&gt; <ins>shelf.close()</ins>
</pre></div></div>

     <p>If the filename supplied to <span class="darkgreen">open()</span> does not exist, the file 
         is created. Be careful, though—if a file does exist, you could be writing to a shelf that 
         contains existing objects without knowing it. Also, the filename that you specify is the base 
         filename for the actual file or files that store the shelves' data. Multiple files with various 
         extensions (the ones you usually see are <b>.dat</b>, <b>.dir</b> and <b>.bak</b>) may be created when 
         you use <b>shelve</b>, so don't be surprised if you find more files than you initially expected.</p>
        
     <p><b>Shelve</b> objects do not automatically close themselves; you must explicitly call the 
         <span class="darkgreen">close()</span> method. However, forgetting to call <span class="darkgreen">close()</span> 
         does not necessarily mean that your shelve assignments don't get written. Also, 
         indexing into a shelve object yields <i>a copy of the stored object</i>, not a reference to the 
         original object. In an interactive Python console, type the commands below as shown:</p>
     
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>            
&gt;&gt;&gt; <ins>import shelve</ins>
&gt;&gt;&gt; <ins>a = [1, 2, 3]</ins>
&gt;&gt;&gt; <ins>b = ['my', 'random', 'text']</ins>
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf2.shlf')</ins>
&gt;&gt;&gt; <ins>shelf['a'] = a</ins>
&gt;&gt;&gt; <ins>shelf['b'] = b</ins>
&gt;&gt;&gt; <ins>shelf.close()</ins>
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf2.shlf')</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
[1, 2, 3]
&gt;&gt;&gt; <ins>shelf['b']</ins>
['my', 'random', 'text']
&gt;&gt;&gt; <ins>shelf['a'].append(4)</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
[1, 2, 3]
&gt;&gt;&gt; <ins>a = shelf['a']</ins>
&gt;&gt;&gt; <ins>a</ins>
[1, 2, 3]
&gt;&gt;&gt; <ins>a.append(4)</ins>
&gt;&gt;&gt; <ins>a</ins>
[1, 2, 3, 4]
&gt;&gt;&gt; <ins>shelf['a'] = a</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
[1, 2, 3, 4]
&gt;&gt;&gt; <ins>shelf.close()</ins>
&gt;&gt;&gt;
</pre></div></div>

     <p>One way to update values in a shelf is to take a copy of the object, 
         change the copy, and reassign that new object to the key to persist it. That seems like a lot of code to write for an 
          update! </p>
        
     <p>You can change shelf values more easily by passing an extra keyword argument, <b>writeback=True</b>, to 
         shelve's <span class="darkgreen">open()</span> function. <b>writeback=True</b> causes shelve to cache access 
         in memory. When the shelf's <span class="darkgreen">sync()</span> or <span class="darkgreen">close()</span> methods 
         are called, the cache is synced back to the actual file. In an interactive Python console, type the 
         commands below as shown:</p>
     
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>            
&gt;&gt;&gt; <ins>import shelve</ins>
&gt;&gt;&gt; <ins>a = [1, 2, 3]</ins>
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf3.shlf')</ins>
&gt;&gt;&gt; <ins>shelf['a'] = a</ins>
&gt;&gt;&gt; <ins>shelf.close()</ins>
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf3.shlf', writeback=True)</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
[1, 2, 3]
&gt;&gt;&gt; <ins>shelf['a'].append(4)</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
[1, 2, 3, 4]
&gt;&gt;&gt; <ins>shelf.sync()</ins>
&gt;&gt;&gt; <ins>shelf.close()</ins>
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf3.shlf')</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
[1, 2, 3, 4]
&gt;&gt;&gt;
</pre></div></div>

     <p>The downside to using <b>writeback</b> is that memory usage is high because of the 
         cache used. Also, because all of the writes are performed on either <span class="darkgreen">sync()</span> or 
         <span class="darkgreen">close()</span>, those operations will take longer, depending on how many changes need 
         to be written. Finally, as mentioned in the introduction to this section, <i>shelve does not maintain 
             references when it persists objects</i>. In an interactive Python console, type the commands below as shown:</p>
        
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>            
&gt;&gt;&gt; <ins>import shelve</ins>
&gt;&gt;&gt; <ins>b = ['my', 'random']</ins>
&gt;&gt;&gt; <ins>a = {'myref':b}</ins>
&gt;&gt;&gt; <ins>a</ins>
{'myref': ['my', 'random']}
&gt;&gt;&gt; <ins>b.append('text')</ins>
&gt;&gt;&gt; <ins>b</ins>
['my', 'random', 'text']
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf4.shlf')</ins>
&gt;&gt;&gt; <ins>shelf['a'] = a</ins>
&gt;&gt;&gt; <ins>shelf['b'] = b</ins>
&gt;&gt;&gt; <ins>shelf.close()</ins>
&gt;&gt;&gt; <ins>shelf = shelve.open(r'v:\workspace\PersistentStorage\src\myshelf4.shlf', writeback=True)</ins>
&gt;&gt;&gt; <ins>shelf['a']</ins>
{'myref': ['my', 'random', 'text']}
&gt;&gt;&gt; <ins>shelf['b']</ins>
['my', 'random', 'text']
&gt;&gt;&gt; <ins>shelf['b'].append('rules')</ins>
&gt;&gt;&gt; <ins>shelf['b']</ins>
['my', 'random', 'text', 'rules']
&gt;&gt;&gt; <ins>shelf['a']</ins>
{'myref': ['my', 'random', 'text']}
&gt;&gt;&gt;
</pre></div></div>

     <p>This makes the shelf a little more like a standard dictionary. That's why many 
         programmers prefer to use shelf in this mode. If your programs terminate in an uncontrolled way, 
         there's a chance that your changes will be lost before they are saved on disk. </p>
    
 </div>
 <a name="h_04"></a><div class="heading">Library Project</div><div class="headingText">

     <p>Now that you've seen some of shelve's capabilities, you can use it to store persistent data in your 
         applications. We'll build a Library class that lets us keep track of books in a persistent data 
         store. We'll also implement methods that let us retrieve a book from our Library class, using its ISBN, 
         title, or author. Let's start with some <span class="purple">tests</span> 
         to help us look up the books. There is one test method for each of those three ways of retrieving 
         a book. </p>
        
     <p>For the tests to have meaning, there must be a library to hold the test data. Such a 
         library is established in the <span class="darkgreen">setUp()</span> method, before each test is performed, and then 
         deleted—perhaps a little too enthusiastically—in the <span class="darkgreen">tearDown()</span> 
         method. Eventually, the 
         library would likely become an external store, but for our test purposes, the 
         "fixture" that the code provides is fine.
     Create <b>test_library.py</b> below as shown: </p>
        
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>import unittest
import library
import os
import glob

class TestLibrary(unittest.TestCase):
    def setUp(self):
        self.lib_fn = r'v:\workspace\PersistentStorage\src\lib.shelve' 
        self.lib = library.Library(self.lib_fn)
        self.fixture_author1 = library.Author('Octavia', 'Estelle', 'Butler')
        self.fixture_book1 = library.Book('0807083100', 'Kindred', 
            [self.fixture_author1])
        self.fixture_author2 = library.Author('Robert', 'Anson', 'Heinlein')
        self.fixture_book2 = library.Book('0441790348', 
            'Stranger in a Strange Land', [self.fixture_author2])
        self.lib.add(self.fixture_book1)
        self.lib.add(self.fixture_book2)

    def testGetByIsbn(self):
        observed = self.lib.get_by_isbn(self.fixture_book1.isbn)
        self.assertEqual(observed, self.fixture_book1)

    def testGetByTitle(self):
        observed = self.lib.get_by_title(self.fixture_book2.title)
        self.assertEqual(observed, self.fixture_book2)

    def testGetByAuthor(self):
        observed = self.lib.get_by_author(self.fixture_book1.authors[0])
        self.assertEqual(observed, self.fixture_book1)

    def tearDown(self):
        self.lib.close()
        shelve_files = glob.glob(self.lib_fn + '*')
        for fn in shelve_files:
            os.remove(fn)

if __name__ == "__main__":
    unittest.main()</ins>
</pre></div></div>

     <p>In addition to the Library class, there are two other classes in the 
         tests—Book and Author. The Book and Author classes are already implemented. These 
         classes contain some special methods (methods that are surrounded by underscores) that will 
         facilitate the development of your Library class. Implementing the special 
         <span class="darkgreen">__eq__()</span> method allows objects to be compared using the <b>==</b> operator. The 
         <span class="darkgreen">__dict__()</span> attribute contains all of the attributes of an object. The combination 
         of the __eq__ method and __dict__ can be used to compare two instances of the same class. 
         Implementing <span class="darkgreen">__eq__()</span> allows you to use the <b>==</b> operator to determine whether two 
         instances of an Author or Book object are the same. As you might have guessed, the <b>!=</b> operator is 
         handled by the <span class="darkgreen">__ne__()</span> method.</p>
        
     <p><b>a == b</b> can be considered equivalent to <b>a.__eq__(b)</b>:</p>
     
     <p></p><div class="c"><img src="./Persistent Storage_files/EqualityEquivalence.png" width="250"></div><p></p>
        
     <p>With Book and Author already written, your job is to implement the library class. Here's a version 
         with stubbed methods. In <b>library.py</b>, type the code below as shown:</p>
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>import shelve

class Library:
    def __init__(self, fn):
        pass

    def add(self, book):
        pass

    def get_by_isbn(self, isbn):
        pass

    def get_by_title(self, title):
        pass

    def get_by_author(self, author):
        pass
    
    def close(self):
        pass
        
class Book:
    def __init__(self, isbn, title, authors):
        self.isbn, self.title, self.authors = isbn, title, authors

    def __eq__(self, other):
        if type(other) is type(self):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

class Author:
    def __init__(self, first_name, middle_name, last_name):
        self.first_name, self.middle_name, self.last_name = first_name, middle_name, last_name

    def __eq__(self, other):
        if type(other) is type(self):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        return not self.__eq__(other)</ins>
</pre></div></div>
        
     <p><img src="./Persistent Storage_files/icon_run.png"> Run your tests; all three should fail:</p>
     
<div class="observeBox"><div class="observeTitle">OBSERVE: Output from test_library.py</div><div class="observe"><pre>FFF
======================================================================
FAIL: testGetByAuthor (__main__.TestLibrary)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\PersistentStorage\src\test_library.py", line 29, in testGetByAuthor
    self.assertEqual(observed, self.fixture_book1)
AssertionError: None != &lt;library.Book object at 0x00B833F0&gt;

======================================================================
FAIL: testGetByIsbn (__main__.TestLibrary)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\PersistentStorage\src\test_library.py", line 21, in testGetByIsbn
    self.assertEqual(observed, self.fixture_book1)
AssertionError: None != &lt;library.Book object at 0x00B83CF0&gt;

======================================================================
FAIL: testGetByTitle (__main__.TestLibrary)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\PersistentStorage\src\test_library.py", line 25, in testGetByTitle
    self.assertEqual(observed, self.fixture_book2)
AssertionError: None != &lt;library.Book object at 0x00BC1550&gt;

----------------------------------------------------------------------
Ran 3 tests in 0.031s

FAILED (failures=3)
</pre></div></div>

     <p>Use the shelve module to implement the missing features. It's not as much code as you might 
         think. Modify your <span class="darkred">Library</span> class as shown:</p>
        
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>class Library:
    def __init__(self, fn):
        <del>pass</del>
        <ins>self.fn = fn
        self.shelf = shelve.open(fn)</ins>

    def add(self, book):
        <del>pass</del>
        <ins>self.shelf[book.isbn] = book</ins>

    def get_by_isbn(self, isbn):
        <del>pass</del>
        <ins>return self.shelf[isbn]</ins>

    def get_by_title(self, title):
        <del>pass</del>
        <ins>for book in self.shelf.values():
            if book.title == title:
                return book
        return None</ins>

    def get_by_author(self, author):
        <del>pass</del>
        <ins>for book in self.shelf.values():
            for a in book.authors:
                if a == author:
                    return book
        return None</ins>
    
    def close(self):
        <del>pass</del>
        <ins>self.shelf.close()</ins>

class Book:
    def __init__(self, isbn, title, authors):
        self.isbn, self.title, self.authors = isbn, title, authors

    def __eq__(self, other):
        if type(other) is type(self):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

class Author:
    def __init__(self, first_name, middle_name, last_name):
        self.first_name, self.middle_name, self.last_name = first_name, middle_name, last_name

    def __eq__(self, other):
        if type(other) is type(self):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        return not self.__eq__(other)
</pre></div></div>
        
     <p>All your tests pass. Those passing tests indicate that Book implementation is working. Check it out:</p>

<div class="observeBox"><div class="observeTitle">OBSERVE:</div><div class="observe"><pre>...
----------------------------------------------------------------------
Ran 3 tests in 2.204s

OK
</pre></div></div>

     <p>The tests take a significant amount of time to run, whereas before, when all our tests failed, it took 
         almost no time at all. Taking notice of these things during early testing can help you avoid an 
         unpromising line of development (though sometimes you want to proceed anyway, to prove a line of 
         reasoning correct). </p>
    
 </div>
 <a href="" name="json"></a>
 <a name="h_05"></a><div class="heading">The JSON Serialization Format and the json Module</div><div class="headingText">
        
     <p><b>pickle</b> and <b>shelve</b> are great for saving objects into persistent storage for other Python programs (that 
         can read and write the same pickle protocol), but there are times when we need to save or transmit 
         objects to programs written in a different language. If we want a human readable, cross-platform and 
         cross-language serialization format, we can use <b>JSON</b>. JSON is actually a subset of JavaScript's 
         object literal syntax. Although it was derived from JavaScript, json parsers exist for many languages. 
         In fact, Python 3 comes with a built-in JSON parser.</p> 
     
     <p>The full details of the JSON syntax are beyond the scope of this course, but if you take a look at an 
         example, you'll see that it is similar to nested Python lists and dicts. If you want to know 
         more about JSON, visit the <a href="http://www.json.org/" target="_blank">JSON website</a>.</p>
     
<div class="observeBox"><div class="observeTitle">OBSERVE: JSON example</div><div class="observe"><pre>            
{
    "foo":"bar",
    "baz":[
        1,
        2,
    ]
}
</pre></div></div>

     <p>If you wanted to serialize a file object or an instance of your custom class, you would have to 
         define a serialization method or function of your own. Even so, JSON is incredibly 
         useful for exchanging data between programs. You can play around with JSON using Python's <b>json</b> 
         module. In an interactive Python console, type the commands below as shown:</p>
     
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import json</ins>
&gt;&gt;&gt; <ins>a = [1, 2, 3]</ins>
&gt;&gt;&gt; <ins>b = ['my', 'text']</ins>
&gt;&gt;&gt; <ins>c = {'a':a, 'b':b, 'none':None, 'true':True}</ins>
&gt;&gt;&gt; <ins>json.dumps(c)</ins>
'{"a": [1, 2, 3], "none": null, "b": ["my", "text"], "true": true}'
&gt;&gt;&gt; <ins>d = json.loads(json.dumps(c))</ins>
&gt;&gt;&gt; <ins>d['a']</ins>
[1, 2, 3]
&gt;&gt;&gt; <ins>d['b']</ins>
['my', 'text']
&gt;&gt;&gt; <ins>d['none']</ins>
&gt;&gt;&gt; <ins>d['true']</ins>
True
&gt;&gt;&gt;
</pre></div></div>

     <p>Just like pickle, the json module has <span class="darkgreen">dump()</span> and <span class="darkgreen">load()</span> 
         functions. But you'll notice that in the example, you used <span class="darkgreen">dumps()</span> and 
         <span class="darkgreen">loads()</span>—both with an "s" at the end. These methods serialize and 
         unserialize an object to and from the json text format, but rather than persisting an object by 
         writing to a file, or reading from persistent object stores (files), these functions produce and 
         consume strings. Typically, json is used when transmitting or exchanging data over the web. The 
         producers and consumers do not share the same file store; instead they send messages over the network. 
         Consequently, it's more common to serialize objects for transmission, rather than persist them in 
         a file when using the json module.</p>
        
     <p></p><div class="c"><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note"> Both <span class="darkgreen">dumps()</span> and <span class="darkgreen">loads()</span> functions can be found in  
         the pickle module. They can be used for serialization there, without persistence for content. 
         (The pickle is usually a convenient format when two Python programs 
         communicate).</td></tr></tbody></table></div><p></p>
        
     <p>JSON defines a few primitive data types—strings, numbers, and booleans, as well as objects and 
         arrays. Curly brackets signify an object. Like Python dicts, JSON objects contain a comma-separated list 
         of colon-separated key/value pairs. The values of objects can be any of the types supported by JSON. 
         Arrays, like Python lists, are delimited by square brackets and elements are comma-separated. Like 
         objects, the elements can be of any type supported by JSON. Well-formatted <b>json</b> is 
         not difficult to read. But you may already notice a major drawback with this format—it
         cannot map every Python type. The supported Python-to-JSON data type mappings are:</p>
        
     <table class="tbl"><tbody><tr><th>Python</th><th>JSON</th></tr><tr><td>dict</td><td>object</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int, float</td><td>number</td></tr><tr><td>True</td><td>true</td></tr><tr><td>False</td><td>false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table>
   
 </div>
 <a name="h_06"></a><div class="heading">A Brief Rundown</div><div class="headingText">
        
     <p>Serialization means taking a Python object and turning it into a string of bits—either a text or 
         binary format. Deserialization is recreating an object from a text or binary representation of an 
         object. Serialization and deserialization are necessary steps for persistent storage and retrieval of 
         Python objects. Python has a few built-in modules that help deal with serialization and persistence. 
         The pickle module lets you serialize, deserialize, and persist Python objects in a binary format 
         that—for the most part—only Python programs can understand. The shelve module uses the 
         pickle format to store several Python objects using a dictionary-like interface. The json module lets 
         you serialize many of Python's native data types into JSON—a text format that's a subset of
         JavaScript's object literal syntax. Each serialization and persistence module has its own place. If 
         you're writing a Python application that needs to save a complex data structure's state efficiently
         (like a game or a text editor), pickle or shelve may be your solution. If you're looking to offer a 
         feed of data to the web, where your clients can be written in any number of various languages, you 
         would use the json module.</p> 
     <p>Nice job on this lesson! Keep it up. (And you can thank me later for avoiding 
         any of a number of bad pickle joke opportunities.) See you in the next lesson...
          </p>
    
 </div>
<div class="footer"><div id="timeSurvey"><iframe frameborder="0" width="400" height="150" src="./Persistent Storage_files/time_survey.html"></iframe></div>				
				Copyright © 1998-2014 O'Reilly Media, Inc.<br><img src="./Persistent Storage_files/cclicense.png"><br>
				This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
				See <a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a> 
				for more information.
				</div><iframe id="t" width="1" height="1" border="0" style="display:none" src="about:blank"></iframe><script language="javascript">bodyLoaded();</script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44720547-1', 'oreillyschool.com');
  ga('send', 'pageview');
</script></body></html>