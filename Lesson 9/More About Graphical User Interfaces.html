
<!-- saved from url=(0078)http://courses.oreillyschool.com/Python2/MoreAboutGraphicalUserInterfaces.html -->
<html><!-- Copyright (c) 1998-2014 O'Reilly Media, Inc.
			This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
			See http://creativecommons.org/licenses/by-sa/3.0/legalcode for more information.
            --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="./More About Graphical User Interfaces_files/Lab.css"><script async="" src="./More About Graphical User Interfaces_files/analytics.js"></script><script type="text/javascript" src="./More About Graphical User Interfaces_files/Lab.js"></script><script language="javascript"></script><title>More About Graphical User Interfaces</title></head><body id="body" style="font-size: 12px;"><a name="top"></a><div class="title">More About Graphical User Interfaces</div><div class="resize"><a href="http://courses.oreillyschool.com/Python2/MoreAboutGraphicalUserInterfaces.html#top" onclick="changeSize(&#39;smaller&#39;);" class="aS" title="Keep clicking to make fonts smaller">A</a><a href="http://courses.oreillyschool.com/Python2/MoreAboutGraphicalUserInterfaces.html#top" onclick="changeSize(&#39;larger&#39;);" class="aL" title="Keep clikcing to make fonts larger">A</a><a href="http://courses.oreillyschool.com/Python2/MoreAboutGraphicalUserInterfaces.html#top" onclick="lv()" class="lv" title="Adjust Page for High Contrast">HC</a><div id="fh"><p>Click on <span class="aS">A</span> to make all fonts on the page smaller.</p><p>Click on <span class="aL">A</span> to make all fonts on the page larger.</p><p>Click on <span class="lv">HC</span> to toggle high contrast mode. When you move your mouse over 
                 some bold words in high contrast mode, related words are automatically highlighted. Text is shown
                 in black and white. 
             </p></div></div><hr>
    <div class="goalTitle">Lesson Objectives</div><div class="goals">When you complete this lesson, you will be able to:
        
        <ul><li>write programs that respond to events in various ways.</li><li>create windows on the fly for common tasks like 
                opening and saving files.</li><li>bind Events in tkinter.</li><li>use event objects.</li><li>assign focus to a widget.</li><li>create popup menus.</li><li>create simple dialogues.</li><li>use ready-made dialogues.</li></ul></div><hr>
    
 <a name="h_01"></a><div class="heading">GUI Events</div><div class="headingText">
        
     <p>Your program can process several different types of events. The most significant events for most 
         programs are mouse clicks (particularly on buttons) and keystrokes. Some events are processed 
         automatically by the widgets themselves—for example, when you click a radio button or a 
         checkbox, its state is changed automatically without the programmer having to program any specific action. 
         Other events include such things as mouse wheel movements, timers expiring, windows being covered up 
         and exposed, and so on. When you're starting to program GUIs, you can ignore all but the most common 
         events, and let the window manager handle the rest for you. </p>
        
     <p>In this lesson, we'll learn how to write programs that respond to events in various ways. You already 
         know how to read and set the values of some widgets. Now you're going to expand your knowledge and 
         learn to create windows on the fly for common tasks like 
         opening and saving files. </p>
    
 </div>
 <a name="h_02"></a><div class="heading">Binding Events in tkinter</div><div class="headingText">
        
     <p>So far, we've bound event handlers to events using the <b>command</b> configuration option with 
         buttons. Many widgets have a <span class="darkgreen">bind()</span> method that dynamically 
         connects a specific event type to a piece of code in a program. Sometimes you'll need to do this, 
         because not every widget has a natural event to associate with a <b>command</b> configuration 
         option.</p>
        
     <p>A widget's <b>bind()</b> method has two arguments. The first is the name of the event to be bound, and the 
         second is the handler function to run when the event is detected within the widget. Most events are 
         named using strings starting with "&lt;" and ending with "&gt;." For example, a click of the left 
         mouse button is named "&lt;Button-1&gt;."  </p>
     
     <p>For left-handed mice the buttons are reversed, so the same button numbers apply for left-handed 
         users:</p>
     
     <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/threebuttonmice.png"></div><p></p>
        
     <p>Let's see that in action. Create a new Pydev project named <b>MoreGUI</b> and assign it to 
         the <b>Python2_Lessons</b> working set. In the <b>MoreGUI/src</b> folder, create a 
         program named <b>clickreport.py</b> as shown:</p>
        
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>from tkinter import *

root = Tk()

def handler(event):
    print("clicked at", event.x, event.y) 

frame = Frame(root, width=100, height=100)
frame.bind("&lt;Button-1&gt;", handler)
frame.pack()

root.mainloop()</ins>
</pre></div></div>

     <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Save and run it, and click in a few places inside the frame. 
         You see something like this:</p>
     
     <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/clickreport.png"></div><p></p>
     
     <p>Sorry, you won't see those fun little yellow explosions, but each time you left-click the mouse button inside 
         the frame, you'll see a report of the cursor position in the console window.</p>

<div class="observeBox"><div class="observeTitle">OBSERVE:</div><div class="observe"><pre>from tkinter import *

root = Tk()

def <span class="darkgreen">handler(event)</span>:
    print("clicked at", event.x, event.y) 

frame = Frame(root, width=100, height=100)
frame.bind("<span class="darkred">&lt;Button-1&gt;</span>", <span class="darkgreen">handler</span>)
frame.pack()

root.mainloop()
</pre></div></div>

     <p>Our <span class="darkgreen">handler</span> is called whenever <span class="darkred">&lt;Button-1&gt;</span> (the left 
         button on a right-handed mouse, or the right button on a left-handed mouse) is clicked.</p>       

     <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/BindingEventHandlers.png"></div><p></p>
             
     <p>Notice that, unlike the widget <b>command</b> functions, a function bound using a widget's 
         <b>bind()</b> method is called with an argument. This argument is an <i>event</i> object, and contains 
         information about the specific event that triggered the call to the event handler. In this case, 
         the program extracts the (frame-relative) coordinates of the <span class="darkred">&lt;Button-1&gt;</span> 
         mouse click event and prints those.</p>
        
  <a name="s_01"></a><div id="s_01"><div class="subheading">Event Objects</div><div class="subheadingText">
            
      <p>The Event object contains data about an event that has just occurred, and it is passed as a single 
          argument to the event handler function. It has several useful attributes (some others are 
          not listed below because they are difficult to use portably): </p>
            
      <table class="tbl"><tbody><tr><th>Attribute Name </th><th>Purpose </th></tr><tr><td>widget</td><td>The widget in which the triggering event occurred. This allows the same function to 
                  handle events from multiple widgets.</td></tr><tr><td>x, y</td><td>The cursor position where mouse events occurred, relative to the top-left corner of the 
                  widget in which the event occurred. </td></tr><tr><td>x_root, y_root</td><td>The cursor position where mouse events occurred, relative to the top-left corner of the 
                  screen. </td></tr><tr><td>height, width</td><td>The new size of the widget (only set for "&lt;Configure&gt;" events).</td></tr><tr><td>char</td><td>The character code associated with a "&lt;Key&gt;" event. </td></tr></tbody></table>
        
  </div></div>
  <a name="s_02"></a><div id="s_02"><div class="subheading">Mouse Event Names</div><div class="subheadingText">
            
      <p>You'll need to be able to describe events when you ask <b>tkinter</b> to establish event bindings. As you 
          saw in the code example above, you can capture a left-click of the mouse with the 
          event name "<b>&lt;Button-1&gt;</b>". </p>
            
      <p>You may also run in to code that uses "<b> &lt;ButtonPress-1&gt;</b>" or "<b>&lt;1&gt;</b>" as a 
          name for the same event. These are equivalent, but we prefer the first form because it's less ambiguous. 
          As you might expect, you can use "<b>&lt;Button-2&gt;</b>" and "<b>&lt;Button-3&gt;</b>" (and their
          equivalents) to refer to clicks of the middle and right buttons respectively. You can also detect 
          double- and triple-clicks with <b>"&lt;Double-Button-<i>n</i>&gt;"</b> and 
          <b>"&lt;TripleButton-<i>n</i>&gt;"</b> (where <i>n</i> is 1, 2, or 3).</p>
            
      <p>You can capture "drag" events—movements of the pointer while a mouse button is held 
          down—with <b>&lt;B1-Motion&gt;</b>, and "drop" events with <b>"&lt;ButtonRelease-1&gt;"</b> 
          (this applies to buttons 2 and 3 as well).</p> 
      
      <p>The <b>"&lt;Enter&gt;"</b> event is raised when the pointer enters the screen area occupied by a 
          particular widget, and the <b>"&lt;Leave&gt;"</b> event occurs when the pointer leaves the area.</p>
       
  
  </div></div>
  <a name="s_03"></a><div id="s_03"><div class="subheading">Keyboard Event Names</div><div class="subheadingText">
            
      <p>You can capture the events that occur when the user presses particular keys, using the event 
          name <b>"&lt;Key&gt;"</b>. When such an event occurs, the event's <b>char</b> attribute tells you 
          which key was pressed (unless it was a special key, like one of the arrow keys or a Shift key. Each 
          of these keys has a special name, which can be used to bind event handlers. </p>
            
      <p>The special key event names are <b>"&lt;Cancel&gt;"</b> (the Break key), <b>"&lt;BackSpace&gt;,"</b> 
          <b>"&lt;Tab&gt;,"</b> <b>"&lt;Return&gt;,"</b>(the Enter key) <b>"&lt;Shift_L&gt;"</b> (any Shift 
          key), <b>"&lt;Control_L&gt;"</b> (any Control key), <b>"&lt;Alt_L&gt;"</b> (any Alt key), 
          <b>"&lt;Pause&gt;,"</b> <b>"&lt;Caps_Lock&gt;,"</b> <b>"&lt;Escape&gt;,"</b> <b>"&lt;Prior&gt;"</b> 
          (Page Up), <b>"&lt;Next&gt;"</b> (Page Down), <b>"&lt;End&gt;,"</b> <b>"&lt;Home&gt;,"</b> 
          <b>"&lt;Left&gt;,"</b> <b>"&lt;Up&gt;,"</b> <b>"&lt;Right&gt;,"</b> <b>"&lt;Down&gt;,"</b> 
          <b>"&lt;Print&gt;,"</b> <b>"&lt;Insert&gt;,"</b> <b>"&lt;Delete&gt;,"</b> <b>"&lt;F1&gt;"</b> 
          through <b>"&lt;F12&gt;,"</b> <b>"&lt;Num_Lock&gt;"s</b>, and <b>"&lt;Scroll_Lock&gt;."</b></p>

      <p>Each individual regular key can also be identified by the string containing the character it 
          produces, <i>without</i> the surrounding angle brackets. So, to capture a press of the "A" key,  
          use the event name <b>"A"</b>. Remember that <b>"1"</b> is the name of the event that occurs when 
          the number one (1) key is pressed. But <b>"&lt;1&gt;"</b> is a mouse button binding event. 
          If your program concerns just a couple of keystrokes, it's usually easier to bind
          the individual keystrokes than to bind <b>"&lt;Key&gt;"</b> and then analyze each keystroke.</p>
        
  </div></div>
  <a name="s_04"></a><div id="s_04"><div class="subheading">Keyboard Focus</div><div class="subheadingText">
            
      <p>In a windowed user interface, you can change which widget receives 
          keyboard input. The most straightforward way to assign focus to a widget is to click on it, although 
          that also triggers a mouse event. These events are usually ignored by default, although 
          buttons "expect" to be clicked on, and if a button has an associated command function, clicking on 
          the button will cause that function to be called. Different types of widget handle keyboard input in different 
          ways. </p>
            
      <p>Entry widgets accept most characters and insert them into the value returned by the widget's 
          <span class="darkgreen">get()</span> method. A Radiobutton will only action a space, 
          which is equivalent to selecting that widget from its associated set (automatically clearing any 
          others in the same set). You can also change the focus by pressing the <b>Tab</b> key (or  
          <b>Shifted+Tab</b> to move in the opposite direction). </p>
            
      <p>Dialog boxes are special cases, with specific behaviors. The <b>Enter</b> key is equivalent to 
          clicking the default button in the dialog (which is configured with <b>default=ACTIVE</b>) and 
          the <b>Esc</b> key is equivalent to clicking the <b>Cancel</b> button. </p>
        
  </div></div>
  <a name="s_05"></a><div id="s_05"><div class="subheading">Keyboard Event Handling</div><div class="subheadingText">
            
      <p>When an event is fired by the window manager (for example, when you press a key or click a 
          mouse button) then the event fires first in the component that is "topmost" in the window layout. 
          So when you click a button, since the button is (usually) inside a frame, the click is sent first 
          to the button. </p>
            
      <p>Now, buttons and the other "canned" widgets are special cases, because they make sure that events 
          upon which they take action are never seen by anything "below" them. In general though, this 
          is not so the case. Events are normally distributed to every widget that is part of the hierarchy. So, 
          when you click the mouse on a frame with a parent that is the root window, the click event is 
          delivered first to the frame and then to the root window. It works the same way with keyboard events. </p>
            
      <p>In our next program we'll investigate this feature. Create a new Python file in the 
          <b>MoreGUI/src</b> folder named <b>evtreport.py</b>, as shown:</p> 
      
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>from tkinter import *

root = Tk()

def handler(event):
    print("Keystroke '{0}' ({1}) {2} ".format(event.char, len(event.char), event.keycode)) 

frame = Frame(root, width=100, height=100)
frame.bind("&lt;Key&gt;", handler)
frame.pack()
frame.focus()

root.mainloop()</ins>
</pre></div></div>
      
      <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Save and run it. Click inside the window, and then 
          try pressing a variety of keys. Most keystrokes are reported. If you look carefully, you'll see 
          that not all keystrokes have a character associated with them. (Which ones don't? It's a challenge to 
          handle these keys in a platform-independent way, because they vary according to hardware and 
          operating systems). If you hold a key down, the automatic repetition associated with doing this are 
          reported as separate keystrokes (even though no physical key movement on the keyboard). If your 
          "Caps Lock" key is like mine, it also repeats despite the lack of physical keystrokes.</p>

<div class="observeBox"><div class="observeTitle">OBSERVE: evtreport.py</div><div class="observe"><pre>from tkinter import *

root = Tk()

<span class="darkblue">def handler(event):
    print("Keystroke '{0}' ({1}) {2} ".format(event.char, len(event.char), event.keycode)) </span>

<span class="darkred">frame = Frame(root, width=100, height=100)</span>
<span class="darkgreen">frame.bind("&lt;Key&gt;", <span class="darkblue">handler</span>)</span>
frame.pack()
<span class="purple">frame.focus()</span>

root.mainloop()
</pre></div></div>
      
      <p><span class="darkred">frame = Frame(root, width=100, height=100)</span> creates a 100 x 100-pixel frame inside 
          the root window. The <span class="darkgreen">bind()</span> function captures all keystroke events in the 
          frame (<span class="purple">frame.focus()</span> ensures that whatever the user types is captured in the 
          frame), and passes them to the <span class="darkblue">handler</span>, which prints the keystroke received.</p>       
            
      <p>You can associate events with the root window of your application if you like. This is a good 
          way to make sure that an event is trapped no matter which widget it is first presented to (so long 
          as that widget doesn't stop the event from propagating through the widget 
          hierarchy). </p>
            
      <p>If you want to trap only certain keys, you can adjust the program so that other key presses 
          aren't handled. This next modification will do that, handling only lower-case "o" and "k."
          Modify <b>evtreport.py</b> as shown:</p>
      
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>from tkinter import *

root = Tk()

def handler(event):
    print("Keystroke '{0}' ({1}) {2} ".format(event.char, len(event.char), event.keycode)) 

frame = Frame(root, width=100, height=100)
<del>frame.bind("&lt;Key&gt;", handler)</del>
<ins>frame.bind("o", handler)
frame.bind("k", handler)</ins>
frame.pack()
frame.focus()

root.mainloop()
</pre></div></div>

      <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Now, most keystrokes don't result in any reporting 
          whatsoever from your program. Since you bound only specific keyboard events to your frame, the handler 
          is triggered only when those events occur. </p>
        
  </div></div>
  <a name="s_06"></a><div id="s_06"><div class="subheading">Event Propagation</div><div class="subheadingText">
            
      <p>So, what happened to the keystrokes that weren't passed to the handler? Were they not 
          passed to the program, or were they passed to the program and then ignored? Events actually propagate 
          back through a widget to its container, and then to that container's container, and so on, until 
          they reach the root window, unless something specifically stops them from propagating. 
          Many of the standard widgets driven by mouse clicks do stop the clicks from propagating; it 
          would be pretty confusing if a button click had multiple effects! You can allow mouse events to
          propagate from the widgets you create in much the same way keyboard 
          events are currently propagating to the root window of the frame.</p>
            
      <p>You can see what the root window is receiving by binding events to your application's root window 
          (which is located between the Frame and the window manager) by adding an event binding with 
          a separate handler. Modify <b>evtreport.py</b> as shown:</p>

<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>from tkinter import *

root = Tk()

def handler(event):
    print("Keystroke '{0}' ({1}) {2} ".format(event.char, len(event.char), event.keycode)) 

<ins>def handler2(event):
    print("RootKeystroke '{0}' ({1}) {2} ".format(event.char, len(event.char), event.keycode))</ins>

frame = Frame(root, width=100, height=100)
frame.bind("o", handler)
frame.bind("k", handler)
<ins>root.bind("&lt;Key&gt;", handler2)</ins>
frame.pack()
frame.focus()

root.mainloop()
</pre></div></div>
            
      <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Now when you type an "o" or a "k," you see <i>two</i> 
          events being reported (actually, it's the same event being reported twice). The first report
          comes from the Frame, and the second from the root window. Other keys are reported only by the root 
          window because they aren't bound in the frame, so the window manager doesn't notify it about those 
          events.</p>
            
      <p>Is there some way to inhibit this propagation of events up through the container hierarchy? In fact, 
          there is. If your handler returns a specific value, the string "break," this tells the 
          event-processing portion of the window manager to stop propagating the event. This doesn't just 
          apply to keystrokes, as our final modification to the event reporter program will demonstrate. 
          Modify <b>evtreport.py</b> as shown: </p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>from tkinter import *

root = Tk()

def handler(event):
    print("Keystroke '{0}' ({1}) {2} ".format(event.char, len(event.char), event.keycode)) 
    <ins>return "break"</ins>

def handler2(event):
    print("RootKeystroke '{0}' ({1}) {2} ".format(event.char, len(event.char), event.keycode))

<ins>def handler3(event):
    print("Frame clicked at", event.x, event.y)
    if event.x &gt; 50 and event.y &gt; 50:
        return "break"
    
def handler4(event):
    print("Root clicked at", event.x, event.y)</ins>
    
frame = Frame(root, width=100, height=100)
frame.bind("o", handler)
frame.bind("k", handler)
<ins>frame.bind("&lt;Button-1&gt;", handler3)</ins>
root.bind("&lt;Key&gt;", handler2)
<ins>root.bind("&lt;Button-1&gt;", handler4)</ins>
frame.pack()
frame.focus()

root.mainloop()
</pre></div></div>
            
      <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Now that the first handler has been modified to return 
          "break," you can see that the "o" and "k" keystroke events no longer propagate to the root window, 
          so each keystroke is reported <i>either</i> by the Frame or by the root window. </p>
            
      <p>Mouse clicks work similarly, though in those cases <i>some</i> clicks are reported by both widgets. 
          Clicks in the lower-right quadrant of the frame don't propagate to the root window, because their 
          x and y attributes are both greater than 50. </p>
        
  </div></div>
 </div>
 <a name="h_03"></a><div class="heading">Adding Menus to Your Programs</div><div class="headingText">
        
     <p>Computer users are used to seeing a menu bar at the top of a program's window. Each word on the bar 
         will drop down a list of menu choices of varying lengths when clicked. (Ellipse's <b>Search</b> 
         menu, for example, contains three items). </p>
     
  <a name="s_01"></a><div id="s_01"><div class="subheading">Building a Menu Bar</div><div class="subheadingText"><div class="para"> </div></div></div>
        
     <p>To add a menu bar to a window, instantiate a Menu widget with the window as its parent, and 
         configure it as the window's <b>menu</b> item. Then you can add a pulldown Menu widget to the 
         window's menu bar using the menu bar as its master and calling its 
         <span class="darkgreen">add_cascade()</span> method. Finally, you add choices to the pulldown using the 
         pulldown's <span class="darkgreen">add_command()</span> method. </p>
     
     <p>Let's try it. In your <b>MoreGUI/src</b> folder, create a program named <b>menudemo.py</b> 
         as shown:</p>
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>from tkinter import *

class Application(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.configure(height=75, width=75)
        # create a menu bar
        menu = Menu(root)
        root.config(menu=menu)
        
        filemenu = Menu(menu)
        menu.add_cascade(label="File", menu=filemenu)
        filemenu.add_command(label="New", command=self.callback1)
        filemenu.add_command(label="Open...", command=self.callback2)
        filemenu.add_separator()
        filemenu.add_command(label="Exit", command=self.callback3)
        
        helpmenu = Menu(menu)
        menu.add_cascade(label="Help", menu=helpmenu)
        helpmenu.add_command(label="About...", command=self.callback4)

        self.pack()

    def callback1(self):
        print("You selected 'File | New'")
    
    def callback2(self):
        print("You selected 'File | Open...'")
    
    def callback3(self):
        print("You selected 'File | Exit'")
        self.quit()
    
    def callback4(self):
        print("You selected 'Help | About...'")

root = Tk()
app = Application(master=root)
app.mainloop()</ins>
</pre></div></div>
        
     <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Run the program; you'll see a window with two items 
         on its menu bar, like the one shown below. Each menu item prints out its identifying information, 
         and the <b>File | Exit</b> item actually terminates the program by calling the frame's 
         <span class="darkgreen">quit()</span> method. </p>
        
     <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/menudemo.png"></div><p></p>
     
  <a name="s_02"></a><div id="s_02"><div class="subheading">Creating Popup Menus</div><div class="subheadingText">
            
      <p>You can also create menu structures that display on demand. The usual stimulus for display of a 
          so-called "context menu" is a right-click. So you can bind a <b>&lt;Button-3&gt;</b> event to the 
          widget you want to provide the menu, and then call the menu's <span class="darkgreen">post()</span> method 
          to display it from the right-button event handler. You can extract the screen coordinates of the 
          cursor from the event passed to the handler to make the menu display at the current cursor 
          position. Let's give that a try. Modify <b>menudemo.py</b> as shown:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>from tkinter import *

class Application(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.configure(height=75, width=75)
        # create a menu bar
        menu = Menu(root)
        root.config(menu=menu)
        
        filemenu = Menu(menu)
        menu.add_cascade(label="File", menu=filemenu)
        filemenu.add_command(label="New", command=self.callback1)
        filemenu.add_command(label="Open...", command=self.callback2)
        filemenu.add_separator()
        filemenu.add_command(label="Exit", command=self.callback3)
        
        helpmenu = Menu(menu)
        menu.add_cascade(label="Help", menu=helpmenu)
        helpmenu.add_command(label="About...", command=self.callback4)

        <ins>self.cmenu = Menu(self)
        self.cmenu.add_command(label="Copy", command=self.copy)
        self.cmenu.add_command(label="Paste", command=self.paste)
        self.bind("&lt;Button-3&gt;", self.popup)</ins>
        
        self.pack()

    def callback1(self):
        print("You selected 'File|New'")
    
    def callback2(self):
        print("You selected 'File|Open...'")
    
    def callback3(self):
        print("You selected 'File|Exit'")
        self.quit()
    
    def callback4(self):
        print("You selected 'Help|About...'")

    <ins>def copy(self):
        print("Context command 'Copy' selected")

    def paste(self):
        print("Context command 'Paste' selected")

    def popup(self, event):
        self.cmenu.post(event.x_root, event.y_root)</ins>

root = Tk()
app = Application(master=root)
app.mainloop()
</pre></div></div>
            
      <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Click the right mouse button (or if you're using a 
          left-handed mouse, click the left button) inside the program's frame; the context menu appears at
          the position where you clicked:</p>
        
      <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/menudemo1.png"></div><p></p>
      
  </div></div>
  <a name="s_03"></a><div id="s_03"><div class="subheading">Tkinter Tearoff Menus</div><div class="subheadingText">
    
      <p>You may be wondering why menus include a dotted line across the top of them. This is a 
          non-standard convenience feature of <b>tkinter</b> menus: if you click the dotted line, the menu 
          becomes a separate window (which usually appears at the top left of your screen) and you can make 
          selections from the window. Below, you see the context menu from the example above, rendered as a 
          separate window. Clicking on the selections works just as if you had brought up 
          the menu using the right button: </p>
            
      <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/TornOffMenu.png"></div><p></p>

      <p>If you don't want this feature to be active in your windows, add the <b>tearoff=False</b> argument 
          to the menu creation call. That way your users won't see a feature they may not understand.</p>
        
  </div></div>
 </div>
 <a name="h_04"></a><div class="heading">Dialog Boxes</div><div class="headingText">
  
  <a name="s_01"></a><div id="s_01"><div class="subheading">Creating Simple Dialogs</div><div class="subheadingText">
            
      <p>The class of windows called dialog boxes share many characteristics. They are 
          usually <i>modal</i>, which is to say the program behind them becomes non-responsive until 
          the dialog box is either completed or canceled, and they are typically only displayed when a 
          specific task needs to be performed. </p> 
            
      <p>Dialogs aren't usually designed to be resized, and are often laid out with the grid manager to 
          accommodate regular rows of labeled entry fields. Tkinter provides a 
          <span class="darkblue">simpledialog</span> module that defines a <span class="darkred">dialog</span> class that you 
          can subclass to define your own dialogs.</p>
      
      <p>The <b>dialog</b> class provides a basis for extension, including two buttons to complete or cancel the 
          dialog. As an example of <b>dialog</b>, we'll use a program that 
          subclasses the <span class="darkred">dialog</span> class to provide an indication of whether the dialog was 
          completed or canceled by adding a <span class="purple">result</span> attribute. </p>
            
      <p>When painted, a subclass of <span class="darkred">simpledialog.Dialog</span> will contain two buttons: 
          <b>OK</b> and <b>Cancel</b>. The subclass provides a 
          <span class="darkgreen">body(self, master)</span> method. This method creates widgets that are children of  
          the <span class="green"><b>master</b></span> argument. It also provides an 
          <span class="darkgreen">apply(self)</span> method, which will be called only if the <b>OK</b> button 
          is clicked. </p> 
            
      <p>The <span class="darkgreen">body()</span> method sets a 
          result attribute to a default value that indicates the dialog was canceled. Then the 
          <span class="darkgreen">apply()</span> method sets an indication that the <b>OK</b> button was 
          clicked. The dialog is modal, which means that the main program will not be given control until
          the user dismisses the dialog. This only happens when the user clicks <b>OK</b> or <b>Cancel</b>. 
          The code that creates the dialog can look at the result immediately afterwards, and 
          determine whether the dialog should be considered valid. </p>
            
      <p>Enter the code below as <b>dialog.py</b> in the <b>MoreGUI/src</b> folder:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>from tkinter import *
from tkinter.simpledialog import Dialog

class MyDialog(Dialog):
    def body(self, master):
        self.result = None
        for r in range(5):
            for c in range(5):
                b = Button(master, text="Row {0} Col {1}".format(r, c))
                b.grid(row=r, column=c)
        print("Dialog created")

    def apply(self):
        self.result = "OK"

class Application(Frame):
    def create_dialog(self):
        d = MyDialog(self)
        print(d.result)

    def create_widgets(self):
        self.d_button = Button(self, text="Dialog...", command=self.create_dialog)
        self.d_button.pack({"side": "left"})

        self.QUIT = Button(self, text="Quit", fg="red", command=self.quit)
        self.QUIT.pack({"side": "left"})

    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.grid()
        self.create_widgets()

root = Tk()
app = Application(master=root)
app.mainloop()</ins>
</pre></div></div>
            
      <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Save and run it. Click <b>Dialog...</b>. You'll 
          see a window like this:</p>
            
      <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/dialogSample.png"></div><p></p>
            
      <p>You can resize the dialog, but its contents don't respond to this activity. If you click <b>OK</b>, 
          the <span class="darkgreen">apply()</span> method is called and "OK" prints in the console. If you 
          click <b>Cancel</b>, "None" is printed.</p>
        
  </div></div>
  <a name="s_02"></a><div id="s_02"><div class="subheading">Some Ready-Made Dialogs</div><div class="subheadingText">
            
      <p>tkinter provides a number of dialog boxes already programmed for specific purposes. The first set 
          is imported from the <span class="darkblue">tkinter.messagebox</span> module. 
          They all take a <b>title</b> and a <b>message</b> argument, and you can follow those 
          with further keyword arguments to tailor their appearance and behavior: </p>
        
    <div class="c"> <table class="tbl"><tbody><tr><th>Dialog Name</th><th>Appearance</th></tr><tr><td>showinfo</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/showinfo.png"></div></td></tr><tr><td>showwarning</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/showwarning.png"></div></td></tr><tr><td>showerror</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/showerror.png"></div></td></tr><tr><td>askquestion</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/askquestion.png"></div></td></tr><tr><td>askokcancel</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/askokcancel.png"></div></td></tr><tr><td>askyesno</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/askyesno.png"></div></td></tr><tr><td>askyesnocancel</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/askyesnocancel.png"></div></td></tr><tr><td>askretrycancel</td><td><div class="c"><img src="./More About Graphical User Interfaces_files/askretrycancel.png"></div></td></tr></tbody></table></div> 
            
      <p>The keyword arguments available to use include <b>default</b>, which specifies the button  
          selected if the user presses <b>Enter</b>. The button options are: ABORT, RETRY, IGNORE, OK, CANCEL, YES, 
          or NO. These constants are defined in the <span class="darkblue">tkinter.messagebox</span> module along with 
          the dialogs. </p>
            
      <p>You can also set the <b>icon</b> keyword argument to ERROR, INFO, QUESTION, or WARNING, depending on 
          which graphic you want to include with the message. You can set the <b>type</b> argument to be: 
          ABORTRETRYIGNORE, OK, OKCANCEL, RETRYCANCEL, YESNO, or YESNOCANCEL. </p>
            
      <p>The <b>askcolor</b> dialog, from the <span class="darkblue">tkinter.colorchooser</span> module, 
          allows you to tell your programs the color you want something to be. It normally 
          returns a two-element tuple; the first element is a tuple of RGB values, the second is a string 
          representing the color format used for web content (#RRGGBB). If you cancel the 
          selection, both elements of the tuple are <b>None</b>.</p>
            
      <p>The <span class="darkblue">filedialog</span> module provides support for selecting directories and 
          files. With files, <span class="darkblue">filedialog</span> supports either loading (providing the selected file exist)
          or saving. With modules, dialogs will display 
          tkinter's limitations. 
          We'll see <span class="darkblue">filedialog</span> in action in our last example of this lesson. 
          In your <b>MoreGUI/src</b> 
          folder, create <b>dialogdemo.py</b> as shown:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>from tkinter import *
from tkinter.filedialog import LoadFileDialog, SaveFileDialog, Directory
from tkinter.colorchooser import askcolor
from tkinter.messagebox import (showinfo, showwarning, showerror, askquestion,
                                askokcancel, askyesno, askyesnocancel, askretrycancel) 


class Application(Frame):
    def askdir(self):
        d = Directory(self)
        print(d.show())

    def messages(self):
        print("info", showinfo("Spam", "Egg Information"))
        print("warning", showwarning("Spam", "Egg Warning"))
        print("error", showerror("Spam", "Egg Alert"))
        print("question", askquestion("Spam", "Question?"))
        print("proceed", askokcancel("Spam", "Proceed?"))
        print("yes/no", askyesno("Spam", "Got it?"))
        print("yes/no/cancel", askyesnocancel("Spam", "Want it?"))
        print("try again", askretrycancel("Spam", "Try again?"))

    def file_open(self):
        d = LoadFileDialog(self)
        fname = d.go("nosuch.txt", "*.py")
        if fname is None:
            print("Canceled...")
        else:
            print("Open file", fname)
    
    def file_save(self):
        d = SaveFileDialog(self)
        fname = d.go("example", "*.py")
        if fname is None:
            print("Canceled...")
        else:
            print("Saving file", fname)
    def color(self):
        d = askcolor()
        print(d)
    
    def createWidgets(self):
        d_button = Button(self)
        d_button.config(width=12, text="Directory Test", command=self.askdir)
        d_button.pack(side=TOP)
        m_button = Button(self)
        m_button.config(width=12, text="Messages Test", command=self.messages)
        m_button.pack()
        c_button = Button(self)
        c_button.config(width=12, text="Color Choice", command=self.color)
        c_button.pack()
        l_button = Button(self)
        l_button.config(width=12, text="Open File", command=self.file_open)
        l_button.pack()
        s_button = Button(self)
        s_button.config(width=12, text="Save File", command=self.file_save)
        s_button.pack()
        self.QUIT = Button(self)
        self.QUIT.config(width=12, text="Quit", fg="red", command=self.quit)
        self.QUIT.pack(side=TOP)

    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.createWidgets()

root = Tk()
app = Application(master=root)
app.mainloop()</ins>
</pre></div></div>
            
      <p><img src="./More About Graphical User Interfaces_files/icon_run.png"> Save and run it. You'll see a window with various 
          buttons:</p>
            
      <p></p><div class="c"><img src="./More About Graphical User Interfaces_files/dialogdemo.png"></div><p></p>
            
      <p>Click the buttons for examples of the <span class="darkblue">filedialog</span> uses we talked about.</p> 
        
  </div></div>
     
     <p>And there you have it! This concludes our discussion of the <b>tkinter</b> library. Next up—Databases! 
         See you there!</p>
    
 </div>
<div class="footer"><div id="timeSurvey"><iframe frameborder="0" width="400" height="150" src="./More About Graphical User Interfaces_files/time_survey.html"></iframe></div>				
				Copyright © 1998-2014 O'Reilly Media, Inc.<br><img src="./More About Graphical User Interfaces_files/cclicense.png"><br>
				This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
				See <a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a> 
				for more information.
				</div><iframe id="t" width="1" height="1" border="0" style="display:none" src="about:blank"></iframe><script language="javascript">bodyLoaded();</script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44720547-1', 'oreillyschool.com');
  ga('send', 'pageview');
</script></body></html>