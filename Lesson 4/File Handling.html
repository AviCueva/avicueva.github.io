
<!-- saved from url=(0058)http://courses.oreillyschool.com/Python2/FileHandling.html -->
<html><!-- Copyright (c) 1998-2014 O'Reilly Media, Inc.
			This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
			See http://creativecommons.org/licenses/by-sa/3.0/legalcode for more information.
            --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="./File Handling_files/Lab.css"><script async="" src="./File Handling_files/analytics.js"></script><script type="text/javascript" src="./File Handling_files/Lab.js"></script><script language="javascript"></script><title>File Handling</title></head><body id="body" style="font-size: 12px;"><a name="top"></a><div class="title">File Handling</div><div class="resize"><a href="http://courses.oreillyschool.com/Python2/FileHandling.html#top" onclick="changeSize(&#39;smaller&#39;);" class="aS" title="Keep clicking to make fonts smaller">A</a><a href="http://courses.oreillyschool.com/Python2/FileHandling.html#top" onclick="changeSize(&#39;larger&#39;);" class="aL" title="Keep clikcing to make fonts larger">A</a><a href="http://courses.oreillyschool.com/Python2/FileHandling.html#top" onclick="lv()" class="lv" title="Adjust Page for High Contrast">HC</a><div id="fh"><p>Click on <span class="aS">A</span> to make all fonts on the page smaller.</p><p>Click on <span class="aL">A</span> to make all fonts on the page larger.</p><p>Click on <span class="lv">HC</span> to toggle high contrast mode. When you move your mouse over 
                 some bold words in high contrast mode, related words are automatically highlighted. Text is shown
                 in black and white. 
             </p></div></div><hr>
    <div class="goalTitle">Lesson Objectives</div><div class="goals">When you complete this lesson, you will be able to:
        
        <ul><li>use some of Python's high-level file handling capabilities.</li><li>get information from and navigate in our 
                file system.</li><li>search for files.</li><li>archive and compress files.</li><li>use the file object and the built-in open() function.</li><li>retrieve file and path name information with os.path.</li><li>find path names using glob.</li></ul></div><hr>

 <a name="h_01"></a><div class="heading">High-Level File Operations</div><div class="headingText">
 
     <p>Now that we have a framework for testing and developing our code, it's time to start looking 
         at some of Python's other built-in modules. In the next few lessons, we'll learn about various 
         Python features, and we'll use <i>TDD</i> to develop small programs with the new features that 
         we learn.</p>

     <p>In this lesson, we will explore some of Python's high-level file handling capabilities. Python 
         has lots of built-in functions and modules geared to help streamline the file handling process. 
         They smooth over many 
         differences between operating system platforms, so you'll have a single interface 
         for dealing with files, whether you're on Windows, OS X, or Linux. First we'll review how to 
         read and write files, then, we'll learn how to get information from and navigate in our 
         file system, search for files, and archive and compress our files. 
         We'll be playing with these features:</p>

     <ul><li>the file object and the built-in open() function</li><li>os.path</li><li>glob</li></ul>

 </div>
 <a name="h_02"></a><div class="heading">The File Object and the Built-in open() Function</div><div class="headingText">

     <p>Our first example involves the file object. You will create a module that can 
         <i>read in</i>the contents of a file as a list of lines (without using file.readline or 
         file.readlines), and <i>write out</i> a list of lines as a file. 
         When the <span class="darkgreen">read()</span> function is applied to the file that <span class="darkgreen">write()</span> 
         creates, it produces the 
         same list as that which is passed in to the <span class="darkgreen">write()</span> function.
         Unlike 
         standard file methods, these functions deal with lines that do not contain the terminating newline. </p>
        
     <p>You'll use newline as the delimiter. The file that you get after you write out a list containing the delimiter, 
         does not need to produce the same list when it's read back in, so you don't have to figure out whether the 
         lines contain the delimiter.</p>
        
     <p>The <span class="darkgreen">setUp()</span> method establishes a common file name and creates a set of test fixtures (particular 
         lists that we have arbitrarily chosen to test the code). Each of the individual test methods 
         calls a common <span class="darkgreen">verify_file()</span> function with one of the test 
         fixtures as its second argument.</p>
     
     <p> Let's start by writing some tests, 
         <span class="darkred">test_fileops.py</span>, and stubbing out (that is, creating a "stub" program that doesn't do anything, 
         so the other program(s) calling it don't show errors) your module, 
         <span class="darkred">fileops.py</span>. Don't forget to add a new test case if you add a new fixture!</p>
     
     <p>Create your <b>FileHandling</b> project and assign it to the <b>Python2_Lessons</b> working 
         set. Then create <b>test_fileops.py</b> as shown:</p> 
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>import unittest
import os
import fileops

class TestReadWriteFile(unittest.TestCase):
    """Test case to verify list read/write functionality."""    

    def setUp(self):
        """This function is run before each test."""
        self.fixture_file = r"v:\workspace\FileHandling\src\test-read-write.txt"
        self.fixture_list = ["my", "written", "text"]
        self.fixture_list_empty_strings = ["my", "", "", "written", "text"]
        self.fixture_list_trailing_empty_strings = ["my", "written", "text", "", ""]
      
    def verify_file(self, fixture_list):
        """Verifies that a given list, when written to a file,
        is returned by reading the same file."""
        fileops.write_list(self.fixture_file, fixture_list)
        observed = fileops.read_list(self.fixture_file)
        self.assertEqual(observed, fixture_list,
                          "%s does not equal %s" % (observed, fixture_list))

    def test_read_write_list(self):
        self.verify_file(self.fixture_list)
        
    def test_read_write_list_empty_strings(self):
        self.verify_file(self.fixture_list_empty_strings)

    def test_read_write_list_trailing_empty_strings(self):
        self.verify_file(self.fixture_list_trailing_empty_strings)

    def tearDown(self):
        """This function is run after each test."""
        try:
            os.remove(self.fixture_file)
        except OSError:
            pass  

if __name__ == "__main__":
    unittest.main()</ins>
</pre></div></div>
        
     <p><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note">In this course, we use the <i>absolute</i> path "v:\workspace" in some cases to gain access to files on the system. 
         In a real-life situation, we strongly advise using <i>relative</i> paths, which are easier to maintain and more portable. 
         For more information about absolute and relative paths, see <a href="http://en.wikipedia.org/wiki/Path_%28computing%29" target="_blank">this Wikipedia article</a>.</td></tr></tbody></table></p>
     
     <p>Generally, each unit test should test just one function or method at 
         a time. Otherwise our code will produce fragile tests, that may break as code is refactored. 
         Our example is a special case, though. We're trying to match the input of 
         <span class="darkgreen">write_list()</span> with the output of <span class="darkgreen">read_list()</span>, and 
         rewriting the implementation of one function in our tests just to test the other seems 
         redundant. </p>
        
     <p>You'll see an error marker on the <b>import fileops</b> line because we haven't created 
         <b>fileops.py</b> yet, so we can't run this program. </p>
     
     <p>Now, let's <i>stub</i> the functions in <b>fileops.py</b>. The stubbed module provides functions with the 
         correct interface, but no functionality. We don't expect the tests to succeed when we run them, 
         but if the stubbed module is correctly structured we'll see <i>failures</i> rather than 
         <i>errors</i>. </p>
         
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>"""Reads a list from a file and writes a list to a file."""

def write_list(fn, lst):
    """Writes a list to a named file. Each list item will be on 
    a separate line. Overwrites the file if it already exists.
    """
    pass
                
def read_list(fn, lst):
    """Reads a list from a file without using readline. 
    Uses standard line endings ("\n") to delimit list items.
    """
    pass</ins>
</pre></div></div>
        
     <p><img src="./File Handling_files/icon_run.png"> Save <b>fileops.py</b>, then run 
         <b>test_fileops.py</b>. Your output will look like this:</p> 

<div class="observeBox"><div class="observeTitle">OBSERVE: Output from running test_fileops.py with the stubbed module</div><div class="observe"><pre><span class="red">EEE</span>
======================================================================
ERROR: test_read_write_list (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 24, in test_read_write_list
    self.verify_file(self.fixture_list)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 19, in verify_file
    observed = fileops.read_list(self.fixture_file)
TypeError: <span class="red">read_list() missing 1 required positional argument: 'lst'</span>

======================================================================
ERROR: test_read_write_list_empty_strings (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 27, in test_read_write_list_empty_strings
    self.verify_file(self.fixture_list_empty_strings)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 19, in verify_file
    observed = fileops.read_list(self.fixture_file)
TypeError: <span class="red">read_list() missing 1 required positional argument: 'lst'</span>

======================================================================
ERROR: test_read_write_list_trailing_empty_strings (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 30, in test_read_write_list_trailing_empty_strings
    self.verify_file(self.fixture_list_trailing_empty_strings)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 19, in verify_file
    observed = fileops.read_list(self.fixture_file)
TypeError: <span class="red">read_list() missing 1 required positional argument: 'lst'</span>

----------------------------------------------------------------------
Ran 3 tests in 0.016s

FAILED (errors=3)
</pre></div></div>

     <p>The "E" reports indicate that there is some mismatch between the tests and the stub. You need to 
         get rid of any such problems before you replace the stubs with real functionality. The error 
         messages let us know that we're expecting too many arguments in our <span class="darkgreen">read_list()</span> function. 
         Modify <b>fileops.py</b> as shown:</p>
          
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""Reads a list from a file and writes a list to a file."""

def write_list(fn, lst):
    """Writes a list to a named file. Each list item will be on 
    a separate line. Overwrites the file if it already exists.
    """
    pass
                
def read_list(fn<del>, lst</del>):
    """Reads a list from a file without using readline. 
    Uses standard line endings ("\n") to delimit list items.
    """
    pass
</pre></div></div>

        <p><img src="./File Handling_files/icon_run.png"> Save it, and then run <b>test_fileops.py</b>. 
         All the tests fail with "F" now, but that's a good thing—it means that the interfaces in the tests match those 
         in the stubbed code. Your output will look something like this:</p> 
             
<div class="observeBox"><div class="observeTitle">OBSERVE: Output from running test_fileops.py with the stubbed module</div><div class="observe"><pre><span class="red">FFF</span>
======================================================================
FAIL: test_read_write_list (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 24, in test_read_write_list
    self.verify_file(self.fixture_list)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 21, in verify_file
    "%s does not equal %s" % (observed, fixture_list))
AssertionError: <span class="red">None != ['my', 'written', 'text'] : None does not equal ['my', 'written', 'text']</span>

======================================================================
FAIL: test_read_write_list_empty_strings (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 27, in test_read_write_list_empty_strings
    self.verify_file(self.fixture_list_empty_strings)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 21, in verify_file
    "%s does not equal %s" % (observed, fixture_list))
AssertionError: <span class="red">None != ['my', '', '', 'written', 'text'] : None does not equal ['my', '', '', 'written', 'text']</span>

======================================================================
FAIL: test_read_write_list_trailing_empty_strings (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 30, in test_read_write_list_trailing_empty_strings
    self.verify_file(self.fixture_list_trailing_empty_strings)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 21, in verify_file
    "%s does not equal %s" % (observed, fixture_list))
AssertionError: <span class="red">None != ['my', 'written', 'text', '', ''] : None does not equal ['my', 'written', 'text', '', '']</span>

----------------------------------------------------------------------
Ran 3 tests in 0.016s

FAILED (failures=3)
</pre></div></div>
     
     <p>The <b>FAIL</b> messages include enough traceback to identify the specific lines that are causing 
        problems in the tests, and the error messages give you a pretty clear idea of what needs to 
         be fixed (hint: don't return <span class="red">"None"</span>!) </p>
        
     <p>So now, let's fill out the stubs with real code. Modify <b>fileops.py</b> as shown: </p>

<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""Reads a list from a file and writes a list to a file."""

def write_list(fn, lst):
    """Writes a list to a file. Each list item will be on a separate line. 
    Overwrites the file if it already exists."""<ins>
    f = open(fn, "w")
    for item in lst:
        f.write("%s\n" % item)
    f.close()</ins>
    <del>pass</del>
                
def read_list(fn):
    """Reads a list from a file without using readline. Uses unix style line 
    endings ("\n") to delimit list items."""<ins>
    f = open(fn, "r")
    s = f.read()
    f.close()
    l = s.split("\n")
    return l</ins>
    <del>pass</del>
</pre></div></div>
        
     <p>This looks like it might work, so let's run our tests again. Bummer—more failures. Can 
         you work out what the problem is, using the information in the messages?</p>
     
<div class="observeBox"><div class="observeTitle">OBSERVE: Output from test_fileops.py after filling out the stub code in fileops.py</div><div class="observe"><pre><span class="red">FFF</span>
======================================================================
FAIL: test_read_write_list (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 24, in test_read_write_list
    self.verify_file(self.fixture_list)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 21, in verify_file
    "%s does not equal %s" % (observed, fixture_list))
AssertionError: <span class="red">Lists differ: ['my', 'written', 'text', ''] != ['my', 'written', 'text']

First list contains 1 additional elements.
First extra element 3:


- ['my', 'written', 'text', '']
?                         ----

+ ['my', 'written', 'text'] : ['my', 'written', 'text', ''] does not equal ['my', 'written', 'text']</span>

======================================================================
FAIL: test_read_write_list_empty_strings (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 27, in test_read_write_list_empty_strings
    self.verify_file(self.fixture_list_empty_strings)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 21, in verify_file
    "%s does not equal %s" % (observed, fixture_list))
AssertionError: <span class="red">Lists differ: ['my', '', '', 'written', 'text', ''] != ['my', '', '', 'written', 'text']

First list contains 1 additional elements.
First extra element 5:


- ['my', '', '', 'written', 'text', '']
?                                 ----

+ ['my', '', '', 'written', 'text'] : ['my', '', '', 'written', 'text', ''] does not equal ['my', '', '', 'written', 'text']</span>

======================================================================
FAIL: test_read_write_list_trailing_empty_strings (__main__.TestReadWriteFile)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_fileops.py", line 30, in test_read_write_list_trailing_empty_strings
    self.verify_file(self.fixture_list_trailing_empty_strings)
  File "V:\workspace\FileHandling\src\test_fileops.py", line 21, in verify_file
    "%s does not equal %s" % (observed, fixture_list))
AssertionError: <span class="red">Lists differ: ['my', 'written', 'text', '', '', ''] != ['my', 'written', 'text', '', '']

First list contains 1 additional elements.
First extra element 5:


- ['my', 'written', 'text', '', '', '']
?                               ----

+ ['my', 'written', 'text', '', ''] : ['my', 'written', 'text', '', '', ''] does not equal ['my', 'written', 'text', '', '']</span>

----------------------------------------------------------------------
Ran 3 tests in 0.047s

FAILED (failures=3)
</pre></div></div>

     <p>If you examine the results carefully, you'll see that each observed result from the 
         <span class="darkgreen">read_line()</span> function contains an extra empty string. The problem is that your 
         <span class="darkgreen">write_list()</span> function is inserting a <b>newline</b> after each line it writes. When you 
         read the file back in with the <span class="darkgreen">read_list()</span> function, the 
         <span class="darkgreen">split("\n")</span> method expects strings on either side of each delimiter, so an 
         extra blank line appears.</p>
        
     <p>We can write our code to anticipate those newlines, but we have to make sure that we our files are still
         handled correctly in other ways. It's possible for a file, under certain circumstances, 
         to be written <i>without</i> a final newline. The fix should take that possibility into account 
         and take action only when the final character in the file is a newline terminator. 
         Apply the fix as shown:</p>
        
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""Reads a list from a file and writes a list to a file."""

def write_list(fn, lst):
    """Writes a list to a file. Each list item will be on a separate line. 
    Overwrites the file if it already exists."""
    f = open(fn, "w")
    for item in lst:
        f.write("%s\n" % item)
    f.close()
                
def read_list(fn):
    """Reads a list from a file without using readline. Uses unix style line 
    endings ("\n") to delimit list items."""
    f = open(fn, "r")
    s = f.read()
    f.close()<ins>
    # If the last character in the file is a newline, delete it
    if s[-1] == "\n":
        s = s[:-1]</ins>
    l = s.split("\n")
    return l
</pre></div></div>
        
     <p><img src="./File Handling_files/icon_run.png"> Run it again. Ah. Success! We finally see the correct result:</p>
        
<div class="observeBox"><div class="observeTitle">OBSERVE:</div><div class="observe"><pre>...
----------------------------------------------------------------------
Ran 3 tests in 0.109s

OK
</pre></div></div>
 <p>Good job.</p>  
 </div>
 <a name="h_03"></a><div class="heading">Retrieving File and Path Name Information with os.path</div><div class="headingText">
        
     <p>The file system identifies files by name and location. The technical term for the name-and-location data 
         is a <i>path</i> or <i>path name</i>. It details how to navigate through a sequence of folders 
         to the required file. You can extract information from these path names by using the <b>os.path</b> 
         module. Different platforms have different path name conventions (for example, Windows uses "\" as its 
         path name separator while Unix-like operating systems use "/").</p>
        
     <p><b>os.path</b> is actually just a reference to another module that is platform specific. When your 
         system loads the <b>os</b> module, code in that module selects and loads the appropriate submodule 
         as <b>os.path</b>. On Windows, the submodule being used behind the scenes is 
         <b>os.ntpath</b>. It has the same interface as os.path, so you can use most functions interchangeably. 
         But using os.ntpath on its own means that you can only use Windows-style path names. 
         <b>os.posixpath</b> is the path module for all operating systems that use Unix-style path names, 
         such as Linux and OS X.</p> 
        
     <p>os.path contains utility functions for retrieving path name and file attribute information. Open an 
         interactive session to see what <b>os.path</b> can do. We'll start out by creating a <b>temp directory</b> using 
         its <span class="darkgreen">mkdir()</span> function, and then go ahead and use other features. In an interactive shell, type
     the code as shown:</p>
     
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import os</ins>
&gt;&gt;&gt; <ins>os.mkdir(r"v:\tmp")</ins>
&gt;&gt;&gt; <ins>f1 = open(r"v:\tmp\file1.txt", "w")</ins>
&gt;&gt;&gt; <ins>f2 = open(r"v:\tmp\file2.txt", "w")</ins>
&gt;&gt;&gt; <ins>f1.close()</ins>
&gt;&gt;&gt; <ins>f2.close()</ins>
&gt;&gt;&gt; <ins>f1.name</ins>
'v:\\tmp\\file1.txt'
&gt;&gt;&gt; <ins>f2.name</ins>
'v:\\tmp\\file2.txt'
&gt;&gt;&gt; <ins>os.path.exists(f1.name)</ins>
True
&gt;&gt;&gt; <ins>os.path.exists(f2.name)</ins>
True
&gt;&gt;&gt; <ins>os.path.exists(r"v:\tmp\file3.txt")</ins>
False
&gt;&gt;&gt; <ins>os.path.getmtime(f1.name)</ins>
1270492734.5412514
&gt;&gt;&gt; <ins>os.path.getmtime(f2.name)</ins>
1270492746.6686897
&gt;&gt;&gt; <ins>os.path.basename(f1.name)</ins>
'file1.txt'
&gt;&gt;&gt; <ins>os.path.basename("v:\\tmp\\")</ins> 
''
&gt;&gt;&gt; <ins>name, extension = os.path.splitext(f1.name)</ins>
&gt;&gt;&gt; <ins>name</ins>
'v:\\tmp\\file1'
&gt;&gt;&gt; <ins>extension</ins>
'.txt'        
&gt;&gt;&gt; <ins>os.path.dirname(f1.name)</ins>
'v:\\tmp'
&gt;&gt;&gt; <ins>os.path.split(f1.name)</ins>
('v:\\tmp', 'file1.txt')
&gt;&gt;&gt; <ins>joined = os.path.join(r"v:\tmp", "file1.txt")</ins>
&gt;&gt;&gt; <ins>joined</ins>
'v:\\tmp\\file1.txt'
&gt;&gt;&gt; <ins>os.path.exists(joined)</ins>
True
&gt;&gt;&gt; <ins>joined = os.path.join(os.path.dirname(f1.name), os.path.basename(f1.name))</ins>
&gt;&gt;&gt; <ins>joined</ins>
'v:\\tmp\\file1.txt'
&gt;&gt;&gt; <ins>os.path.abspath(r"v:\tmp\..\tmp\file1.txt")</ins>
'v:\\tmp\\file1.txt'
</pre></div></div>
      
     
     <p><span class="darkgreen">os.path.exists()</span> returns <b>True</b> if the path passed as an argument actually 
         exists. On some platforms, the return value may differ based on file permissions and symbolic 
         links.</p>
        
     <p><span class="darkgreen">os.path.getmtime()</span> returns the amount of time (in seconds) between your 
         platform's epoch date (the origin of time for your particular platform—for example, for 
         Windows, getmtime would return the number of seconds since January 1st, 1601)—and the last time that a 
         file was modified. <span class="darkgreen">getmtime()</span> is part of a group of functions that retrieves 
         time information from a file. <span class="darkgreen">getatime()</span> returns the last time the file was 
         accessed and <span class="darkgreen">getctime()</span> returns the time the file was created (on Unix-like 
         systems, this is actually the last time a file was changed). You can convert these times to 
         human-readable strings using functions from the <b>time</b> module, which we will look at later in 
         this course.</p>
        
     <p>As the module's name implies, <b>os.path</b> contains functions for manipulating path names. 
         <span class="darkgreen">os.path.basename()</span> returns the last path name component without any slashes. 
         You can consider the basename as you would an actual filename component of a full path. If the path supplied 
         to <span class="darkgreen">basename()</span> ends in a slash, an empty string will be returned (because there 
         is no filename component). To retrieve the path to the file, but not the file name itself, you can use
         <span class="darkgreen">os.path.dirname()</span>.</p>
     
     <div class="c"><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note">In the os.path.basename example, we can't create a raw string literal ending with a single backslash 
         (r"v:\tmp\"), so we instead used the non-raw string with double backslashes ("v:\\tmp\\"). Although backslashes are 
         mostly treated as normal characters in raw string literals rather than altering the significance of the following 
         character, any following quote character is always treated as part of the string literal. This is so that quote 
         characters can still appear in string literals. For more information, see this 
         <a href="http://stackoverflow.com/questions/647769/why-cant-pythons-raw-string-literals-end-with-a-single-backslash" target="_blank">stackoverflow article</a>.</td></tr></tbody></table></div>
        
     <p>The <span class="darkgreen">os.path.split()</span> function returns a tuple. The tuple's first element is what 
         <span class="darkgreen">dirname()</span> would return; its second element is what 
         <span class="darkgreen">basename()</span> would return. </p> 
        
     <p><span class="darkgreen">os.path.join()</span> does the opposite of <span class="darkgreen">split()</span>; it joins 
         path components together into full path names. It will add a slash between components 
         where necessary, and you can give it as many arguments as you like. Joining the 
         <span class="darkgreen">dirname()</span> and <span class="darkgreen">basename()</span> of a path gives back the 
         original path.</p>

 </div>
 <a name="h_04"></a><div class="heading">Finding Path Names Using glob</div><div class="headingText">
        
     <p>So now you know how to read and write files, but what if you want to find a file? For that, you'll need the 
         <span class="darkgreen">glob()</span> function, which lives in the module of the same name. 
         <span class="darkgreen">glob()</span> finds paths that match a particular pattern. The  
         symbols and patterns in the table below are the same <i>wildcards</i> you might use in your command shell and 
         many other places: </p>
        
   <div class="c"> <table class="tbl"><tbody><tr><th>Symbol</th><th>Description</th><th>Example</th></tr><tr><td>?</td><td>Match any single character exactly once.</td><td>?ar matches bar or tar, but not star.</td></tr><tr><td>*</td><td>Match any number of characters.</td><td>*ar matches bar, tar, star and exemplar.</td></tr><tr><td>[characters or character range]</td><td>Match exactly one character in a range or set.</td><td>[a-z]ar matches tar, but not star or 4ar</td></tr></tbody></table></div> 
        
     <p>Now, using the interactive shell, we're going to create a directory containing the following files: 
         <b>test1.txt</b>, <b>test2.txt</b>, <b>test3.txt</b>, and <b>another.one</b>. 
         Let's see what <span class="darkgreen">glob()</span> can do 
         with these files. Type this code into an interactive Python console:</p>

<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>for i in range(1,4):</ins>
...     <ins>f  = open(r"v:\tmp\test"+str(i)+".txt", "w")</ins>
...     <ins>f.close()</ins>
... 
&gt;&gt;&gt; <ins>f = open(r"v:\tmp\another.one", "w")</ins>
&gt;&gt;&gt; <ins>f.close()</ins>
&gt;&gt;&gt; <ins>import glob</ins>
&gt;&gt;&gt; <ins>os.chdir(r"v:\tmp")</ins>
&gt;&gt;&gt; <ins>glob.glob("*.*")</ins>
['another.one', 'file1.txt', 'file2.txt', 'test1.txt', 'test2.txt', 'test3.txt']
&gt;&gt;&gt; <ins>glob.glob("*.txt")</ins>
['file1.txt', 'file2.txt', 'test1.txt', 'test2.txt', 'test3.txt']
&gt;&gt;&gt; <ins>glob.glob("*.one")</ins>
['another.one']
&gt;&gt;&gt; <ins>glob.glob("test?.txt")</ins>
['test1.txt', 'test2.txt', 'test3.txt']
&gt;&gt;&gt; <ins>glob.glob("test[1-2].txt")</ins>
['test1.txt', 'test2.txt']
</pre></div></div>
        
     <p>As long as their names share a 
         common pattern, you can access your chosen files. There are also ways to read all of the entries within a 
         directory, or even to walk through an 
         entire directory tree, but we'll address that in a later course. </p>
    
 </div>
 <a name="h_05"></a><div class="heading">An Application to Sort and Retrieve File Information</div><div class="headingText">        
     <p>Let's try using the <b>glob</b> and <b>os.path</b> modules to create a function that returns a list 
         of the most recently modified files from a particular path. It will take as arguments, the number of 
         files that we want returned, and the path where we'll look for the files. You'll reuse and modify 
         the module from our last example, so don't worry about error handling just yet. To develop the good programming
         habits you're going to have, start out with some tests!</p>
     <p> In the directory listing below,
         file.old is the oldest of the three listed files, and file.new the newest:</p>
        
     <p></p><div class="c"><img src="./File Handling_files/fileDir.png"></div><p></p>
     
     <p>In your <b>FileHandling</b> project, create a new file named <b>test_latest.py</b> as shown:</p>  
        
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>import unittest
import latest
import time
import os

PATHSTEM = "v:\\workspace\\FileHandling\\src\\"

class TestLatest(unittest.TestCase):

    def setUp(self):
        self.path = PATHSTEM
        self.file_names = ["file.old", "file.bak", "file.new"]
        for fn in self.file_names:
            f = open(self.path+fn, "w")
            f.close()
            time.sleep(1)
            
    def test_latest_no_number(self):
        """
        Ensure that calling the function with no arguments returns
        the single most recently-created file.
        """
        expected = [self.path + "file.new"]
        latest_file = latest.latest(path=self.path)
        self.assertEqual(latest_file, expected,)

    def test_latest_with_args(self):
        """
        Ensure that calling the function with arguments of 2 and some
        directory returns the two most recently-created files in the directory.
        """
        expected = set([self.path + "file.new", 
            self.path + "file.bak"])
        latest_files = set(latest.latest(2, self.path))
        self.assertEqual(latest_files, expected)

    def tearDown(self):
        for fn in self.file_names:
            os.remove(self.path + fn)

if __name__ == "__main__":
    unittest.main()</ins>
</pre></div></div>
     
     <p><img src="./File Handling_files/icon_save.png"> Save it. You can't run the tests just yet—you 
         need to have something to test first. The <b>TestLatest</b> class, above, defines two tests 
         with common <b>setUp</b> and <b>tearDown</b>. The <b>setUp</b> will take a little longer than our previous tests, 
         because it needs to create three files with different creation times, and it <i>sleeps</i> for a second after 
         setting up each file. </p>
     
     <p></p><div class="c"><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note">If you want to use these tests in a different location, change the code to suit the local 
         environment by modifying the PATHSTEM assignment.</td></tr></tbody></table></div><p></p>
        
     <p>Your unit tests show that your function should be able to take in arguments for the 
         number of recent files that you want returned, and the path where it will look for your files. It 
         should also work if you let your function use its default arguments. </p>

     <p>Now, let's create the <b>latest.py</b> module for the test module to import:</p>
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>import glob
import os

def latest(num=1, path="."):
    pass</ins>
</pre></div></div>
     
     <p><img src="./File Handling_files/icon_save.png"> Save it, and then run <b>test_latest.py</b>:</p>

<div class="observeBox"><div class="observeTitle">OBSERVE: Output from test_latest.py</div><div class="observe"><pre>FE
======================================================================
ERROR: test_latest_with_args (__main__.TestLatest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_latest.py", line 34, in test_latest_with_args
    latest_files = set(latest.latest(2, self.path))
TypeError: 'NoneType' object is not iterable

======================================================================
FAIL: test_latest_no_number (__main__.TestLatest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_latest.py", line 25, in test_latest_no_number
    self.assertEqual(latest_file, expected,)
AssertionError: None != ['v:\\workspace\\file.new']

----------------------------------------------------------------------
Ran 2 tests in 6.031s

FAILED (failures=1, errors=1)         
</pre></div></div>

     <p>What's wrong here? In this case, the issue is with the behavior of the stub function. 
         The stub function is returning <b>None</b>, but the <b>test_latest_with_args()</b> test expects a list back from 
         <b>latest.latest()</b>. We can fix that, but how? Pause, ponder, and 
         reflect on that for a minute before going on to the 
         next part...</p>
     
     <p>Okay, now let's see if you can get your tests to pass! 
         Modify <b>latest.py</b> as shown:</p>
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>import glob
import os

def latest(num=1, path="."):
    <del>pass</del>
    <ins>return []</ins>
</pre></div></div>

        <p><img src="./File Handling_files/icon_save.png"> Save it and run <b>test_latest.py</b>.</p>
             
<div class="observeBox"><div class="observeTitle">OBSERVE:</div><div class="observe"><pre>FF
======================================================================
FAIL: test_latest_no_number (__main__.TestLatest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_latest.py", line 25, in test_latest_no_number
    self.assertEqual(latest_file, expected,)
AssertionError: Lists differ: [] != ['v:\\workspace\\python2_Lesso...

Second list contains 1 additional elements.
First extra element 0:
v:\workspace\FileHandling\src\file.new

- []
+ ['v:\\workspace\\FileHandling\\src\\file.new']

======================================================================
FAIL: test_latest_with_args (__main__.TestLatest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\FileHandling\src\test_latest.py", line 35, in test_latest_with_args
    self.assertEqual(latest_files, expected)
AssertionError: Items in the second set but not the first:
'v:\\workspace\\FileHandling\\src\\file.new'
'v:\\workspace\\FileHandling\\src\\file.bak'

----------------------------------------------------------------------
Ran 2 tests in 6.047s

FAILED (failures=2)
</pre></div></div>
        
     <p>Excellent! A little modification to the stub makes sure that your tests fail properly—without errors!
        The default messages from the failed assertions contain lots of detail to help you figure out why your tests are failing.</p>
     
     <p>Now we need to make our tests pass. Edit <b>latest.py</b> as shown:</p>
     
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>import glob
import os

def latest(num=1, path="."):
    <ins>files_with_dates = []
    files = glob.glob(os.path.join(path, "*"))
    latest_files = []
    for fn in files:
        files_with_dates.append((os.path.getmtime(fn), os.path.abspath(fn)))
    files_with_dates.sort()
    for file_info in files_with_dates[-num:]:
        latest_files.append(file_info[1]) 
    latest_files.reverse()
    return latest_files</ins>
    <del>return []</del>
</pre></div></div>
     
     <p>The <span class="darkgreen">setUp()</span> method (which is run before each 
         test) needs to create three files with the right sequence of creation times. The test's <span class="darkgreen">setUp()</span> 
         method contains a <i>sleep</i> to make sure that the files' creation times differ by at least one second.</p>
     
     <p>Save it and run the test. Both tests should pass:</p>

<div class="observeBox"><div class="observeTitle">OBSERVE:</div><div class="observe"><pre>.. 
----------------------------------------------------------------------
Ran 2 tests in 6.115s

OK            
</pre></div></div>
    <p>Nice. </p>
        
  <a name="s_01"></a><div id="s_01"><div class="subheading">The Value of Tests under Refactoring</div><div class="subheadingText">
            
      <p>Another technique used to produce the most recent files is 
          <a href="http://www.python.org/dev/peps/pep-0202/" target="_blank">list comprehension</a>. 
          List comprehensions reduce the amount of code in your program. </p>
      
             <p><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note">Shorter code is not always better. Less code could lead to decreased readability.
                 Readability is one of the most important 
          attributes of your code, and should only be sacrificed when performance demands it. 
          It's up to you to decide which way to go. </td></tr></tbody></table></p>
      
      <p>Let's try using list comprehensions. Modify <b>latest.py</b> as shown:</p>       
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>import glob
import os

def latest(num=1, path="."):
    <del>files_with_dates = []</del>
    files = glob.glob(os.path.join(path, "*"))
    <ins>dated_files = [(os.path.getmtime(fn), os.path.abspath(fn)) for fn in files]
    dated_files.sort()
    latest_files = [f for (d, f) in dated_files[-num:]]</ins>
    latest_files.reverse()
    return latest_files
</pre></div></div>
            
     <p>The <span class="darkgreen">latest()</span> function uses a technique called "decorate-sort-undecorate" to 
         achieve its goal. The file paths need to be sorted by date, so it builds a list of 
         <b>(date, filename)</b> tuples, which Python can sort more easily (the date is the "decoration" here, 
         because it isn't required in the result, even though it's necessary for sorting.) By default, the tuples 
         are sorted into ascending order, so the paths of the most recent files will be located at the 
         end.</p>
        
     <div class="c"><img src="./File Handling_files/DecorateSortUndecorate.png"></div>
        
     <p>So, the algorithm (the set of instructions for completing the task) extracts 
         just the filenames of the most recent files, by using the 
         negative index located in this chunk of code:</p><br>
     
      <p></p><div class="c"><span class="code">[for file_info in files_with_dates[-num:]]</span> </div><p></p> 
     
     <p><b>-<i>num</i></b> makes it go backwards through values of <i>num</i>, then reverses 
         the result, placing the most recent files at the beginning. In other words, 
         <b>-<i>num</i></b> takes us backwards from end of the list,
         by <i>num</i> elements (for example, zoo[-5:] would start at the end of zoo and
         move back five elements, then chop from there to the end of the list).          
         So since the list of files was sorted to get the most recently 
         modified ones last, this clips off the <i>num</i> most recent files and
         then shares them in oldest-to-newest order.</p>
         
      <p>When you run your tests, the one-second delay between file creations causes the run to take over six seconds, but the output 
         should be two successful tests. </p>
     
      <p><img src="./File Handling_files/icon_run.png"> Save and run it. With the new 
          <b>latest</b> module, your tests still pass. All is well, and you can move ahead feeling confident 
          that nothing is broken (or at least nothing that you're testing for is broken). </p>
        
  </div></div>
 </div>
 <a name="h_06"></a><div class="heading">Getting a Handle on Files</div><div class="headingText">
        
     <p>I'm glad to see you're becoming familiar with some of Python's high-level file handling features: the <b>glob</b> module 
         and <b>os.path</b>. To reiterate, the <b>glob</b> module 
         helps you to search for files using patterns, while <b>os.path</b> helps to retrieve file information, used 
         to do various path name acrobatics—like getting the file name out of a full path or 
         splitting and joining path names. </p>
     
     <p>Now, what do pickles and shelves have in common? We'll find out in the next lesson—see you 
         there!</p>
     
 </div>
<div class="footer"><div id="timeSurvey"><iframe frameborder="0" width="400" height="150" src="./File Handling_files/time_survey.html"></iframe></div>				
				Copyright © 1998-2014 O'Reilly Media, Inc.<br><img src="./File Handling_files/cclicense.png"><br>
				This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
				See <a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a> 
				for more information.
				</div><iframe id="t" width="1" height="1" border="0" style="display:none" src="about:blank"></iframe><script language="javascript">bodyLoaded();</script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44720547-1', 'oreillyschool.com');
  ga('send', 'pageview');
</script></body></html>