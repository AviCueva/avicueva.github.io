
<!-- saved from url=(0067)http://courses.oreillyschool.com/Python2/EmailSearchAndDisplay.html -->
<html><!-- Copyright (c) 1998-2014 O'Reilly Media, Inc.
			This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
			See http://creativecommons.org/licenses/by-sa/3.0/legalcode for more information.
            --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="./Email Search and Display_files/Lab.css"><script async="" src="./Email Search and Display_files/analytics.js"></script><script type="text/javascript" src="./Email Search and Display_files/Lab.js"></script><script language="javascript"></script><title>Email Search and Display</title></head><body id="body" style="font-size: 12px;"><a name="top"></a><div class="title">Email Search and Display</div><div class="resize"><a href="http://courses.oreillyschool.com/Python2/EmailSearchAndDisplay.html#top" onclick="changeSize(&#39;smaller&#39;);" class="aS" title="Keep clicking to make fonts smaller">A</a><a href="http://courses.oreillyschool.com/Python2/EmailSearchAndDisplay.html#top" onclick="changeSize(&#39;larger&#39;);" class="aL" title="Keep clikcing to make fonts larger">A</a><a href="http://courses.oreillyschool.com/Python2/EmailSearchAndDisplay.html#top" onclick="lv()" class="lv" title="Adjust Page for High Contrast">HC</a><div id="fh"><p>Click on <span class="aS">A</span> to make all fonts on the page smaller.</p><p>Click on <span class="aL">A</span> to make all fonts on the page larger.</p><p>Click on <span class="lv">HC</span> to toggle high contrast mode. When you move your mouse over 
                 some bold words in high contrast mode, related words are automatically highlighted. Text is shown
                 in black and white. 
             </p></div></div><hr>
    
    <div class="goalTitle">Lesson Objectives</div><div class="goals">When you complete this lesson, you will be able to:
        
        <ul><li>write a program to create the necessary table in the MySQL database.</li><li>create a library to handle storage and retrieval of information in the database.</li><li>write tests that exercise the storage and retrieval functionality.</li><li>write a GUI-based 
                program to query the database and display the resulting messages.</li></ul></div><hr>
 
 <a name="h_01"></a><div class="heading">A Really Useful Program</div><div class="headingText"> 
        
     <p>You have picked up lots of empowering skills in this course. You know how to build GUIs, you understand 
         about various types of persistent storage, and you can handle email. In this last lesson, we'll build
         an email storage and retrieval mechanism, then attach that to a graphical user interface so that 
         the user can enter various search criteria and click on a button to see a list of matching messages. 
         Clicking on a message from the list will display the message body. Not only that, but the messages 
         will be stored in a relational database on an entirely different computer from the one running
         the program. How cool is that?</p>
        
     <p>So, how will we be able to search the email? Potentially by date and by partial match on the names and 
         email addresses of senders. We'll also be able to extend this software to handle 
         additional headers as retrieval keys. </p>
        
     <p>We'll start by writing a program to create the necessary table in the MySQL database. We'll 
         follow that with a library to handle storage and retrieval of information in the database, along 
         with tests that exercise the storage and retrieval functionality. Finally, we'll write a GUI-based 
         program to query the database and display the resulting messages. </p>
    
 </div>
 <a name="h_02"></a><div class="heading">A Basic Email Database</div><div class="headingText">
        
     <p>To store messages, we need a defined structure. A single table is the simplest store, so for now, 
         we'll develop a single-table store. Once the basic message storage function is working (and 
         tested!), we'll add columns to the table to enable new types of retrieval. </p>
        
  <a name="s_01"></a><div id="s_01"><div class="subheading">Message Identities</div><div class="subheadingText">
            
      <p>The modern email system is pretty good about allocating each individual message a globally-unique 
          identification, which is carried in the <b>Message-Id</b> header. Here's a sample header from the 
          author's current inbox:</p>
          
<div class="observeBox"><div class="observeTitle">OBSERVE: Sample Email Header</div><div class="observe"><pre>Message-ID: &lt;20100529085040.32283.76682@betelnutz&gt;
</pre></div></div>
            
      <p>To keep relationships efficient and representations clear, each message in the database will have 
          <i>two</i> unique columns. There will be <b>msgID</b> (an integer column automatically inserted as 
          necessary by the RDBMS and used as the primary key) and <b>msgMessageID</b> (the globally-unique 
          mail system identifier). <b>msgID</b> will be used to refer to a message wherever possible in the 
          system. Messages themselves do sometimes refer to each other by the <b>Message-ID</b> value though, 
          so that access path is worth putting into even a basic implementation.</p>
            
      <p>This initial implementation records the <b>Message-ID</b> header value as a database column so you 
          can use SQL to query it. Later, certain other information will also be extracted from the messages 
          and recorded directly in the database for the same reason. This will allow full relational 
          operations on that data, letting the database do the retrieval tasks for which it is optimized.</p>
        
     <p>The store needs an <i>Application Programmer Interface</i> or <i>API</i>. This intimidating-sounding 
         thing is actually a set of "how-to instructions for users of the message store." 
         The fundamental operations of storage and retrieval are described in the API. Storing a message  
         requires that the message be passed in to the storage function. Retrieving messages requires some kind of 
         identity to be passed in, and for the function to return a message (or raise some sort of 
         MessageNotFound exception). Since you have decided (well, okay, we've decided) to retrieve 
         with both "msgID" and "MessageID," it makes sense to provide two functions. Here is the API that will help you 
         accomplish your tasks: </p>
        
     <div class="c"><table class="tbl"><tbody><tr><th>Function</th><th>Purpose and interface</th></tr><tr><td>store(msg)</td><td>Adds the message to the store and returns its msgID value. If a message with the same value 
                 for the <b>Message-ID</b> header is already present in the store, the msgID of the existing 
                 message is returned.</td></tr><tr><td>message_by_id(id)</td><td>Returns the message whose primary key value is <b>id</b> or raises an exception if no such 
                 message is present.</td></tr><tr><td>message_by_messageid(message_id)</td><td>Returns the message whose MessageId value is <b>message_id</b> or raises an exception if no 
                 such message is present.</td></tr></tbody></table></div>

     <p>This is only an initial attempt to define the interface. Don't think of it as something set in stone. Often, 
         after working with a newly-designed API for a little while, it turns out to be less than ideal. 
         In that case, feel free to change itâ€”programmer convenience is more 
         important than strict adherence to existing APIs. Never be afraid to rework a 
         portion of your design; well-designed systems are the result of experimentation and revision. </p>
        
  </div></div>
  <a name="s_02"></a><div id="s_02"><div class="subheading">The Message Table</div><div class="subheadingText">
            
      <p>The message store is deliberately uncomplicated. You may be surprised at how sophisticated 
          your queries have become by the end of the lesson. Initially there are just three columns: the <b>id</b> 
          (automatically generated by the database), the <b>Message-ID</b> header value, and the <b>message</b>  
          itself, represented in the most fundamental way: as the sequence of characters that was received 
          over the network. This sequence can be parsed by the <span class="darkblue">email</span> module to produce
          <b>email.Message</b> objects. More columns will be added to the database table as its scope and 
          capabilities grow. </p>
            
      <p>Start MySQL at the terminal window, and create this table as shown:</p>
                 
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>mysql&gt; <ins>CREATE TABLE message(</ins>
    -&gt;     <ins>msgID INTEGER AUTO_INCREMENT PRIMARY KEY,</ins>
    -&gt;     <ins>msgMessageID VARCHAR(128),</ins>
    -&gt;     <ins>msgText LONGTEXT) ENGINE = MYISAM;</ins>
Query OK, 0 rows affected (0.18 sec)
</pre></div></div>
            
      <p>That's it. You now have a table in which to store your messages. The message itself is stored as a 
          character sequence in a LONGTEXT column. This particular type of column is designed to allow 
          storage of arbitrary character strings. Email can be tricky stuff to store; not all 
          messages will necessarily be in the same character set and no global default can be applied. 
          (For example, sometimes the header data explains that certain portions of the message are in specific 
          encodings).</p>
            
      

      <p>Processing the message to create an <b>email.Message</b> object is 
          the most efficient way to extract the <b>Message-Id</b> header. For now, if you want to find out 
          anything else about the message once it's been stored, you'll need to read its text in from the database and 
          parse it again. By ensuring all 
          messages are parsed before entering the database, you guarantee they can be parsed upon retrieval.</p>
            
      <p>At some point you may consider using some more efficient storage representation, such as a 
          pickle. But an email is not necessarily best represented as a single object, so your initial 
          approach will be the more conservative one outlined above. Rememberâ€”first, make it work! You 
          can update the storage mechanism later if necessary.</p>
            
      <p>You only need two pieces of data in order to insert a new row (representing a new message) into the message 
          table: the Message ID and the bytestring representation of the message. The third 
          column (primary key) will be populated automatically. So if you have the Message ID and the string 
          representation in variables <span class="darkred">message_id</span>, and <span class="darkred">text</span> respectively, 
          along with a database cursor in <span class="purple">curs</span>, the required statement would 
          look like this:</p>
      
<div class="observeBox"><div class="observeTitle">OBSERVE: Inserting Data in the message Table</div><div class="observe"><pre><span class="purple">curs</span>.execute("INSERT INTO message(msgMessageID, msgText) VALUES (%s, %s)",
            (<span class="darkred">message_id</span>, <span class="darkred">text</span>))
</pre></div></div>

  </div></div>
  <a name="s_03"></a><div id="s_03"><div class="subheading">Beginnings of a Mail Database Module</div><div class="subheadingText">
            
      <p>Now that the table has been created, you need Python functionality that allows you to store, and 
          retrieve, email messages.</p>
      
      <p><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note">Users of this API don't need to know how the 
          data is stored in the database. If the API does not provide them with the features they need, 
          knowledge of the structures allows the use of raw SQL, but it's better to try and avoid this. If 
          only your code updates the database, then only you are responsible for its consistency. This is a
          good practice to adhere to in database management.</td></tr></tbody></table> </p>
            
      <p>Before you insert the message into the database, you need to make sure that it isn't in there 
          already. You could either retrieve the set of all rows having the given message ID and make sure that 
          it is empty, or you could count all of the rows with a specific message-id. Since you need the 
          primary key of the message when it <i>is</i> present in the database anyway (to return as the value of 
          the function), you may as well try and retrieve it now.</p>
            
      <p><table class="noteBox fBox pBox "><tbody><tr><td class="noteTitle">Note</td><td class="note">When there is a possibility of retrieving lots of rows, but you only want to know how many 
          there are, it's usually <i>much</i> more efficient to use the SQL <span class="darkgreen">COUNT(*)</span> 
          function we discussed earlier.</td></tr></tbody></table></p>
            
      <p>Create a <b>EmailSearch</b> project and assign it to the <b>Python2_Lessons</b> working set. 
          Copy the <b>database.py</b> file from <b>DatabaseHints/src</b> to your 
          <b>EmailSearch/src</b> folder. Then, in the <b>EmailSearch/src</b> folder, create a new 
          Python file named <b>maildb.py</b> as shown:</p> 
      
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>"""
Email message handling module: contains logic to store
email messages using a MySQL relational database.
"""
from database import login_info
import mysql.connector as msc
from email import message_from_string

conn = msc.Connect(**login_info)
curs = conn.cursor()

def store(msg):
    """
    Stores an email message, if necessary, returning its primary key.
    """ 
    message_id = msg['message-id']
    text = msg.as_string()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if result:
        return result[0]
    curs.execute("INSERT INTO message (msgMessageID, msgText) VALUES (%s, %s)",
             (message_id, text))
    conn.commit()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    return curs.fetchone()[0]</ins>
</pre></div></div>
            
      <p>This <b>maildb</b> module defines a single function, which takes a parsed <b>email.Message</b> and 
          its textual equivalent as arguments. First, the function extracts the message's <b>Message-ID</b> 
          header value, and attempts to retrieve the <b>msgid</b> of the message with that <b>message_id</b> 
          (in case it already exists).</p>

      <p>Sadly, we broke the first rule of test-driven development here! Remember it? "Only write code to make a failing test pass." 
          But we wrote the code before writing 
          the tests. Yes, we have led 
          you down a dark and evil path. Don't let us do it again! Let's write the tests now. To get going in the 
          right direction, we'll even add some tests that we know the existing code cannot pass, and 
          then augment our code to make them pass in true test-driven development fashion.</p>

      <p>In our consideration of email, we saw that the <b>Message-ID</b> header was a possible (candidate) 
          primary key. While we do need to store this value as a column in the database (messaging systems 
          often use <b>Message-ID</b> values to refer to other messages), it should not be the primary 
          keyâ€”it's too long, and strings take longer to compare than numbers. So we made the primary 
          key the <b>msgid</b> column, with values that are automatically allocated as rows are added to the 
          database. </p>
            
      <p>Now we can store messages in the database, right? Well, the only way to test storage is 
          to retrieve data and verify that it agrees with what was stored. So we need a way of 
          getting the information outâ€”in fact we need two ways. We need to be able to retrieve a message with a 
          given primary key, and with a given <b>Message-ID</b> header value. The code for each is somewhat 
          similar. </p>
            
      <p>Here's our testing strategy: each message is reconstituted from a text file, then stored using the 
          <span class="darkgreen">maildb.store()</span> function. As the program iterates over the message files and 
          stores the messages, it builds two dicts. The first one, <b>msgids</b>, maps <b>Message-ID</b> 
          values to primary keys. The second, <b>message_ids</b>, maps primary key values to 
          <b>Message-ID</b> values. The content of the dicts is used by the 
          <span class="darkgreen">test_msg_ids()</span> and <span class="darkgreen">test_message_ids()</span> methods to 
          verify that the expected message does indeed come back after retrieval by one or the other of the 
          keys.</p>
      
      <p>In the <b>EmailSearch/src</b> folder, create a <b>testMaildb.py</b> file as shown:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>"""
Read in and parse email messages to verify readability.

NOTE: This test creates the message table, dropping any
previous version and should leave it empty. DANGER: this
test will delete any existing message table.
"""

from glob import glob
from email import message_from_string
import mysql.connector as msc
from database import login_info
import maildb
import unittest

conn = msc.Connect(**login_info)
curs = conn.cursor()

TBLDEF = """\
CREATE TABLE message (
     msgID INTEGER AUTO_INCREMENT PRIMARY KEY,
     msgMessageID VARCHAR(128),
     msgText LONGTEXT
) ENGINE = MYISAM"""
FILESPEC = "C:/PythonData/*.eml"

class testRealEmail_traffic(unittest.TestCase):
    def setUp(self):
        """
        Reads an arbitrary number of mail messages and
        stores them in a brand new messages table.
        
        DANGER: Any existing message table WILL be lost.
        """
        curs.execute("DROP TABLE IF EXISTS message")
        conn.commit()
        curs.execute(TBLDEF)
        conn.commit()
        files = glob(FILESPEC)
        self.msgids = {} # Keyed by message_id
        self.message_ids = {} # keyed by id
        for f in files:
            ff = open(f)
            text = ff.read()
            msg = message_from_string(text)
            id = self.msgids[msg['message-id']] = maildb.store(msg)
            self.message_ids[id] = msg['message-id']

    def test_not_empty(self):
        """
        Verify that the setUp method actually created some messages.
        If it finds no files there will be no messages in the table,
        the loop bodies in the other tests will never run, and potential
        errors will never be discovered.
        """
        curs.execute("SELECT COUNT(*) FROM message")
        messagect = curs.fetchone()[0]
        self.assertGreater(messagect, 0, "Database message table is empty")
 
    def test_message_ids(self):
        """
        Verify that items retrieved by id have the correct Message-ID.
        """  
        for message_id in self.msgids.keys():
            pk, msg = maildb.msg_by_id(self.msgids[message_id]) 
            self.assertEqual(msg['message-id'], message_id)

    def test_ids(self):
        """
        Verify that items retrieved by message_id have the correct Message-ID.
        """
        for id in self.message_ids.keys():
            pk, msg = maildb.msg_by_message_id(self.message_ids[id])
            self.assertEqual(msg['message-id'], self.message_ids[id])

if __name__  == "__main__":
    unittest.main()</ins>
</pre></div></div>
      
      <p><img src="./Email Search and Display_files/icon_run.png"> Save and run it. The tests fail, because the code 
          calls two retrieval functions that we may not have written yet. In the code editor window, you'll 
          see two error flags in the left margin:</p>
            
      <p></p><div class="c"><img src="./Email Search and Display_files/SyntaxError.png"></div><p></p>
            
      <p>Move your cursor over the red "X," and you'll see a tooltip that says something like 
          "Undefined variable from import: msg_by_id". Even so, Eclipse will let you try and run the 
          program. The resulting AttributeError exceptions cause the test to fail: </p>
            
<div class="observeBox"><div class="observeTitle">OBSERVE: Result of Initial Run of testMaildb.py</div><div class="observe"><pre>EE.
======================================================================
ERROR: test_ids (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 62, in test_ids
    pk, msg = maildb.msg_by_message_id(self.message_ids[id])
<span class="red">AttributeError: 'module' object has no attribute 'msg_by_message_id'</span>

======================================================================
ERROR: test_message_ids (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 54, in test_message_ids
    pk, msg = maildb.msg_by_id(self.msgids[message_id])
<span class="red">AttributeError: 'module' object has no attribute 'msg_by_id'</span>

----------------------------------------------------------------------
Ran 3 tests in 0.688s

FAILED (errors=2)

</pre></div></div>
            
      <p>The tests fail because there is no code present to implement the retrieval functions 
          <span class="darkgreen">msg_by_id()</span> and <span class="darkgreen">msg_by_message_id()</span>. In this case, failure is 
          great newsâ€”it means we're in proper test-driven development mode, now all we have to do is write those 
          functions to pass the tests. Both of the retrieval functions return the message and its 
          primary key. No matter how data is retrieved, store it 
          using the primary key value to select the row to be updated.</p>
            
      <p>The <span class="darkgreen">msg_by_id()</span> function takes a primary key (id) value as its argument and 
          executes a query to retrieve the message (along with the primary key). If this query returns an 
          empty result set, the function raises a KeyError exception. Otherwise, 
          <span class="darkgreen">msg_by_id()</span> extracts the message text and its primary key from the database, 
          and returns the primary key and a newly-parsed mail message.</p> 
            
      <p>This test mechanism is somewhat inefficient because it creates the table and then drops it 
          for each individual test; it would be better to run the data creation once and then run each 
          individual test. But we want to have two separate tests to make sure that a failure in one 
          retrieval routine won't stop us from testing the other, so for now we'll put up with this bit of 
          inefficiency. </p>
            
      <p>Edit your <b>maildb.py</b> library to add this retrieval function as shown:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""
Email message handling module: contains logic to store <ins>and retrieve</ins>
email messages using a MySQL relational database.
"""
from database import login_info
import mysql.connector as msc
from email import message_from_string

conn = msc.Connect(**login_info)
curs = conn.cursor()

def store(msg):
    """
    Stores an email message, if necessary, returning its primary key.
    """ 
    message_id = msg['message-id']
    text = msg.as_string()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if result:
        return result[0]
    curs.execute("INSERT INTO message (msgMessageID, msgText) VALUES (%s, %s)",
             (message_id, text))
    conn.commit()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    return curs.fetchone()[0]
<ins>
def msg_by_id(id):
    """
    Return the (presumably singleton) message whose primary key is given
    or raise KeyError if no such message exists.
    """
    curs.execute("SELECT msgID, msgText FROM message WHERE msgID=%s", (id, ))
    result = curs.fetchone()
    if  not result:
        raise KeyError("Id {0} not found in store".format(id))
    id, text = result
    msg = message_from_string(text)
    return id, msg</ins>
</pre></div></div>
            
      <p>With this new logic in place, one of the tests will succeed when you re-run <b>testMaildb.py</b>:</p>
            
<div class="observeBox"><div class="observeTitle">OBSERVE:</div><div class="observe"><pre>E..
======================================================================
ERROR: test_ids (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 62, in test_ids
    pk, msg = maildb.msg_by_message_id(self.message_ids[id])
<span class="red">AttributeError: 'module' object has no attribute 'msg_by_message_id'</span>

----------------------------------------------------------------------
Ran 3 tests in 0.578s

FAILED (errors=1)

</pre></div></div>
            
      <p>There is little difference between <span class="darkgreen">msg_by_id()</span> and 
          <span class="darkgreen">msg_by_message_id()</span>. It is just a matter of using a slightly different
          condition on the query. Modify <b>maildb.py</b> by adding the code below as shown:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""
Email message handling module: contains logic to store and retrieve
email messages using a MySQL relational database.
"""
from database import login_info
import mysql.connector as msc
from email import message_from_string

conn = msc.Connect(**login_info)
curs = conn.cursor()

def store(msg):
    """
    Stores an email message, if necessary, returning its primary key.
    """ 
    message_id = msg['message-id']
    text = msg.as_string()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if result:
        return result[0]
    curs.execute("INSERT INTO message (msgMessageID, msgText) VALUES (%s, %s)",
             (message_id, text))
    conn.commit()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    return curs.fetchone()[0]

def msg_by_id(id):
    """
    Return the (presumably singleton) message whose primary key is given
    or raise KeyError if no such message exists.
    """
    curs.execute("SELECT msgID, msgText FROM message WHERE msgID=%s", (id, ))
    result = curs.fetchone()
    if  not result:
        raise KeyError("Id {0} not found in store".format(id))
    id, text = result
    msg = message_from_string(text)
    return id, msg
<ins>
def msg_by_message_id(message_id):
    """
    Return the (presumably singleton) message whose "Message-ID" is given
    or raise KeyError if no such message exists.
    """
    curs.execute("SELECT msgID, msgText FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if  not result:
        raise KeyError("Message-Id {0} not found in store".format(message_id))
    id, text = result
    msg = message_from_string(text)
    return id, msg</ins>
</pre></div></div>
            
      <p>Finally, all of our tests pass, and we can proceed to develop this basic library into something we can really use:</p>
      
<div class="observeBox"><div class="observeTitle">OBSERVE: Life is good when tests pass</div><div class="observe"><pre>...
----------------------------------------------------------------------
Ran 3 tests in 0.580s

OK
</pre></div></div>
        
  </div></div>
  <a name="s_04"></a><div id="s_04"><div class="subheading">Extending the Database's Retrieval Capabilities</div><div class="subheadingText">
           
      <p>According to our tests, we can now store email messages in a relational database and retrieve them 
          either by primary key or Message-ID value. The Message-ID is extracted from the message when it is
          stored. It doesn't hurt to leave records lying around after a test, to allow testers to 
          query the database manually and see what else can be done with the records, though 
          the production installers prefer to have the tables left in a known empty state. 
          It <i>certainly</i> doesn't hurt to know that the table passed its basic tests after installation. 
          There are other pieces of information about the messages that you might like to store in the relational 
          database to expand your retrieval capabilities even further. Specifically, you want to be able to
          retrieve messages sent between specific dates and/or times, and from specific senders, by name or 
          address. </p>
            
      <p>To accomplish that, we'll add a new column containing the message date. 
          But it wouldn't be particularly useful 
          to store it as a text column in the database, because the database cannot execute time-based 
          calculations on strings. So instead, after you have extracted the <b>Date</b> 
          header value from the parsed message, convert it into a Python <b>datetime.datetime</b> object, 
          which the database driver will then convert into a MySQL DATETIME value, for storage in the database.</p>
            
      <p>We'll modify the test program, adding a <b>msgDate</b> column to the table definition and add tests 
          of the date retrieval function. We'll write that function later; it will look like this:</p>
                
      <p><b>def msgs_by_date(mindate, maxdate)</b></p>
                
      <p>Retrieval by date is different from retrieval by primary key or <b>Message-ID</b>â€”there is a 
          real possibility that multiple messages will have the same date, causing the new function to return 
          multiple records.</p>
            
      <p>Our tests should work independently of the test data. To test the date 
          routine, we'll change the date creation code in the <span class="darkgreen">setUp()</span> method so that it also 
         records the minimum and maximum datetime and a message count. Then we'll add a third test, 
          <span class="darkgreen">test_dates()</span>, that requests retrieval of all messages between the minimum 
          and maximum datetimes, and verifies that the count is correct, and that all messages have the correct 
          msgid values. Modify <b>testMaildb.py</b> as shown:</p>
      
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""
Read in and parse email messages to verify readability.

NOTE: This test creates the message table, dropping any
previous version and should leave it empty. DANGER: this
test will delete any existing message table.
"""
from glob import glob
from email import message_from_string
import mysql.connector as msc
from database import login_info
import maildb
import unittest
<ins>import datetime
from email.utils import parsedate_tz, mktime_tz</ins>

conn = msc.Connect(**login_info)
curs = conn.cursor()

TBLDEF = """\
CREATE TABLE message (
     msgID INTEGER AUTO_INCREMENT PRIMARY KEY,
     msgMessageID VARCHAR(128),
     <ins>msgDate DATETIME,</ins>
     msgText LONGTEXT
) ENGINE = MYISAM"""
FILESPEC = "C:/PythonData/*.eml"

class testRealEmail_traffic(unittest.TestCase):
    def setUp(self):
        """
        Reads an arbitrary number of mail messages and
        stores them in a brand new messages table.
        
        DANGER: Any existing message table WILL be lost.
        """
        curs.execute("DROP TABLE IF EXISTS message")
        conn.commit()
        curs.execute(TBLDEF)
        conn.commit()
        files = glob(FILESPEC)
        self.msgids = {} # Keyed by message_id
        self.message_ids = {} # keyed by id
        <ins>self.msgdates = []
        self.rowcount = 0</ins>        
        for f in files:
            ff = open(f)
            text = ff.read()
            msg = message_from_string(text)
            id = self.msgids[msg['message-id']] = maildb.store(msg)
            self.message_ids[id] = msg['message-id']
            <ins>date = msg['date']
            self.msgdates.append(datetime.datetime.fromtimestamp(mktime_tz(parsedate_tz(date))))
            self.rowcount += 1 # Assuming no duplicated Message-IDs</ins>

    def test_not_empty(self):
        """
        Verify that the setUp method actually created some messages.
        If it finds no files there will be no messages in the table,
        the loop bodies in the other tests will never run, and potential
        errors will never be discovered.
        """
        curs.execute("SELECT COUNT(*) FROM message")
        messagect = curs.fetchone()[0]
        self.assertGreater(messagect, 0, "Database message table is empty")
 
    def test_message_ids(self):
        """
        Verify that items retrieved by id have the correct Message-ID.
        """  
        for message_id in self.msgids.keys():
            id, msg = maildb.msg_by_id(self.msgids[message_id]) 
            self.assertEqual(msg['message-id'], message_id)
            self.assertEqual(id, self.msgids[message_id])

    def test_ids(self):
        """
        Verify that items retrieved by message_id have the correct Message-ID.
        """
        for id in self.message_ids.keys():
            id1, msg = maildb.msg_by_message_id(self.message_ids[id])
            self.assertEqual(msg['message-id'], self.message_ids[id])
            self.assertEqual(id, id1)

    <ins>def test_dates(self):
        """
        Verify that retrieving records between the minimum and maximum dates
        returns an appropriate number of records.
        """
        mind = min(self.msgdates)
        mindate = datetime.date(mind.year, mind.month, mind.day)
        maxd = max(self.msgdates)
        maxdate = datetime.date(maxd.year, maxd.month, maxd.day)
        self.assertEqual(self.rowcount,
                         len(maildb.msgs_by_date(mindate=mindate,
                                                 maxdate=maxdate)))</ins>
    
if __name__  == "__main__":
    unittest.main()            
</pre></div></div>
            
      <p>By assigning this test the task of creating the table, we ensure that the table definition stays up to date. 
          This is actually the only way the tests can succeedâ€”if SQL refers to a nonexistent 
          column, the Python code that uses it will raise an exception.</p>
      
      <p><img src="./Email Search and Display_files/icon_run.png"> Save and run it. The updated test fails, 
          because we haven't updated the library yet. But hey, at least the original tests are still passing! 
          The new test fails because it calls a function that we haven't written yet:</p>
            
<div class="observeBox"><div class="observeTitle">OBSERVE: </div><div class="observe"><pre>E...
======================================================================
ERROR: test_dates (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 83, in test_dates
    len(maildb.msgs_by_date(mindate=mindate,
<span class="red">AttributeError: 'module' object has no attribute 'msgs_by_date'</span>

----------------------------------------------------------------------
Ran 4 tests in 0.672s

FAILED (errors=1)
</pre></div></div>
            
      <p>We don't need to add much code to store the messagesâ€”the change looks bigger than 
          it otherwise might because some operations have been re-ordered to avoid unnecessary work. We do need 
          to import a couple of bits of code from <b>email.utils</b> and <b>datetime</b>. And, if the record 
          isn't already present, the <span class="darkgreen">store()</span> function extracts and converts the date, 
          before storing it as an additional column in the table.</p>
            
      <p>Now we need some way of retrieving the messages by date. We'll add a 
          <span class="darkgreen">msgs_by_date()</span> function that takes a minimum and/or a maximum date. The SQL 
          that is generated makes sure that only one date will be provided. The 
          parameters are dates rather than date-times, because we assume that 
          humans are more interested in dates than times for most purposes. For the upper limit, we add 
          a day to the given date and use a "less than" comparison. The code requires that at least one 
          criterion be provided, and there is some logic to allow the code to work with either one or two 
          conditions. Modify <b>maildb.py</b> as shown below:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""
Email message handling module: contains logic to store and retrieve
email messages using a MySQL relational database.
"""
from database import login_info
import mysql.connector as msc
from email import message_from_string<ins>
from email.utils import parsedate_tz, mktime_tz
from datetime import datetime, timedelta</ins>

conn = msc.Connect(**login_info)
curs = conn.cursor()

def store(msg):
    """
    Stores an email message, if necessary, returning its primary key.
    """ 
    message_id = msg['message-id']
    <del>text = msg.as_string()</del>
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if result:
        return result[0]<ins>
    date = msg['date']
    dt = datetime.fromtimestamp(mktime_tz(parsedate_tz(date)))
    text = msg.as_string()</ins>
    curs.execute("INSERT INTO message (msgMessageID, <ins>msgDate,</ins> msgText) VALUES (%s, <ins>%s,</ins> %s)",
             (message_id, <ins>dt,</ins> text))
    conn.commit()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    return curs.fetchone()[0]

def msg_by_id(id):
    """
    Return the (presumably singleton) message whose primary key is given
    or raise KeyError if no such message exists.
    """
    curs.execute("SELECT msgID, msgText FROM message WHERE msgID=%s", (id, ))
    result = curs.fetchone()
    if  not result:
        raise KeyError("Id {0} not found in store".format(id))
    id, text = result
    msg = message_from_string(text)
    return id, msg

def msg_by_message_id(message_id):
    """
    Return the (presumably singleton) message whose "Message-ID" is given
    or raise KeyError if no such message exists.
    """
    curs.execute("SELECT msgID, msgText FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if  not result:
        raise KeyError("Message-Id {0} not found in store".format(message_id))
    id, text = result
    msg = message_from_string(text)
    return id, msg
<ins>
def msgs_by_date(mindate=None, maxdate=None):
    if not (mindate or maxdate):
        raise TypeError("Must provide at least one of mindate, maxdate")
    conds = []
    data = []
    if mindate:
        conds.append("msgDate &gt;= %s")
        data.append(mindate)
    if maxdate:
        conds.append("msgdate &lt; %s")
        data.append(maxdate+timedelta(days=1))
    sql = "SELECT msgid, msgText FROM message WHERE "
    sql += " AND ".join(conds)
    curs.execute(sql, tuple(data))
    result = []
    for id, text in curs.fetchall():
        result.append((id, message_from_string(text)))
    return result</ins>
</pre></div></div>
            
      <p><img src="./Email Search and Display_files/icon_run.png"> Save and run it (from <b>testMaildb.py</b>) to 
          verify that all of the tests now pass and also to confirm that we have implemented date-based storage 
          correctly:</p>
            
<div class="observeBox"><div class="observeTitle">OBSERVE:</div><div class="observe"><pre>....
----------------------------------------------------------------------
Ran 4 tests in 0.890s

OK
</pre></div></div>
      <p>Tests all passed. Excellent. Proceed!</p>     
  </div></div>
  <a name="s_05"></a><div id="s_05"><div class="subheading">Practical Application</div><div class="subheadingText">
            
      <p>You might have thought you had the beginnings of a useful library with <b>maildb.py</b>, but the design is 
          missing somethingâ€”descriptions of the practical uses  
          your program could fulfill using the library or <b>use cases</b>.</p>
      
      <p> We know we can retrieve mail by date now, 
          but typically we want to apply the 
          date restrictions along with 
              other constraints, like "sent by user@domain" or "recipients include user@domain." Before 
          we go any further, we'll want to know more about the application that 
          will be using the library. </p>
            
      <p>You can always work directly with the database tables to provide a 
          date-ordered listing of subjects. In the <b>EmailSearch/src</b> folder, create <b>mlist1.py</b> 
          as shown: </p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>"""
Sample program to list subjects by date.
"""
from database import login_info
import mysql.connector
from email import message_from_string
conn = mysql.connector.Connect(**login_info)
curs = conn.cursor()
curs.execute("SELECT msgText FROM message ORDER BY msgDate")
for text, in curs.fetchall():
    msg = message_from_string(text)
    print(msg['date'], msg['subject'])</ins>
</pre></div></div>
            
      <p>So, what are the retrieval requirements of this application? The intention is to allow the user to 
          enter any or all of a start date, an end date, sender's name, and sender's email address, and then 
          to list the dates and subject lines of each message. They should be able to click a message to 
          display it. </p>
            
      <p>As we saw earlier, the existing date field in the table allows us to select 
          dates, but at present, we are not extracting the other necessary 
          valuesâ€”sender's name and email addressâ€”as database columns. We need to fix that. 
          The sender's data are held in the <b>From</b> header. The format of the header data allows the 
          inclusion of both a textual name and email address; the <b>email.utils</b> library has a 
          <span class="darkgreen">parseaddr()</span> function that we can use to move both pieces of information 
          from the <b>From</b> header into a (name, address) tuple. That data can then be stored in two 
          additional columns in the messages table. The code changes are subtle, particularly 
          since we aren't adding any new retrieval routines this time around. Modify <b>maildb.py</b> as shown:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""
Email message handling module: contains logic to store and retrieve
email messages using a MySQL relational database.
"""
from database import login_info
import mysql.connector as msc
from email import message_from_string
from email.utils import parsedate_tz, mktime_tz<ins>, parseaddr</ins>
from datetime import datetime, timedelta

conn = msc.Connect(**login_info)
curs = conn.cursor()

def store(msg):
    """
    Stores an email message, if necessary, returning its primary key.
    """ 
    message_id = msg['message-id']
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if result:
        return result[0]
    date = msg['date']
    <ins>name, email = parseaddr(msg['from'])</ins>
    dt = datetime.fromtimestamp(mktime_tz(parsedate_tz(date)))
    text = msg.as_string()
    curs.execute("""INSERT INTO message
                    (msgMessageID, msgDate, <ins>msgSenderName, msgSenderAddress, </ins>msgText)
                    VALUES (%s, %s, <ins>%s, %s, </ins>%s)""",
                    (message_id, dt, <ins>name, email, </ins>text))
    conn.commit()
    curs.execute("SELECT msgID FROM message WHERE msgMessageID=%s", (message_id, ))
    return curs.fetchone()[0]

def msg_by_id(id):
    """
    Return the (presumably singleton) message whose primary key is given
    or raise KeyError if no such message exists.
    """
    curs.execute("SELECT msgID, msgText FROM message WHERE msgID=%s", (id, ))
    result = curs.fetchone()
    if  not result:
        raise KeyError("Id {0} not found in store".format(id))
    id, text = result
    msg = message_from_string(text)
    return id, msg

def msg_by_message_id(message_id):
    """
    Return the (presumably singleton) message whose "Message-ID" is given
    or raise KeyError if no such message exists.
    """
    curs.execute("SELECT msgID, msgText FROM message WHERE msgMessageID=%s", (message_id, ))
    result = curs.fetchone()
    if  not result:
        raise KeyError("Message-Id {0} not found in store".format(message_id))
    id, text = result
    msg = message_from_string(text)
    return id, msg

<del>def msgs_by_date(mindate=None, maxdate=None):</del>
<ins>def msgs(mindate=None, maxdate=None, namesearch=None, addsearch=None):
    """
    Return a list of all messages sent on or after mindate and on or before maxdate.
    If mindate is not specified, there is no lower bound on the date, and similarly
    if maxdate is not specified, no upper bound. If namesearch is given, the
    result set is restricted to messages with sender names containing that string. If
    addsearch is given, the result set is restricted to messages with email
    addresses containing that string.</ins>
    """ 
    <del>if not (mindate or maxdate):
        raise TypeError("Must provide at least one of mindate, maxdate")</del>
    conds = []
    data = []
    if mindate:
        conds.append("msgDate &gt;= %s")
        data.append(mindate)
    if maxdate:
        conds.append("msgdate &lt; %s")
        data.append(maxdate+timedelta(days=1))
    <ins>if namesearch:
        conds.append("msgSenderName LIKE %s")
        data.append("%" + namesearch.strip().lower() + "%") 
    if addsearch:
        conds.append("msgSenderAddress LIKE %s")
        data.append("%" + addsearch.strip().lower() + "%")</ins>  
    <del>sql = "SELECT msgid, msgText FROM message WHERE "</del>
    <del>sql += " AND ".join(conds)</del>
    <ins>sql = "SELECT msgid, msgText FROM message"
    if conds:
        sql += " WHERE " + " AND ".join(conds)</ins>
    curs.execute(sql, tuple(data))
    result = []
    for id, text in curs.fetchall():
        result.append((id, message_from_string(text)))
    return result 
</pre></div></div>
            
      <p><img src="./Email Search and Display_files/icon_run.png"> Save it and run <b>testMaildb.py</b>.  
          This revision breaks our existing tests. The library now references columns that have not 
          been added to the database yet, so the driver complains during setup for each of the tests 
          when we try to add a row. Also, pay attention to the change of function names in the module. Because the new
          retrieval function we wrote does more now that just retrieve mail by date, its 
          name is something less specialized: <b>msgs</b>.</p>
            
<div class="observeBox"><div class="observeTitle">OBSERVE: test failures are induced by adding new columns in the library code</div><div class="observe"><pre>EEEE
======================================================================
ERROR: test_dates (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 51, in setUp
    id = self.msgids[msg['message-id']] = maildb.store(msg)
  File "V:\workspace\EmailSearch\src\maildb.py", line 30, in store
    (message_id, dt, name, email, text))
  File "C:\python\lib\site-packages\mysql\connector\cursor.py", line 307, in execute
    res = self.db().protocol.cmd_query(stmt)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 137, in deco
    return func(*args, **kwargs)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 482, in cmd_query
    return self.handle_cmd_result(self._recv_packet())
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 175, in _recv_packet
    MySQLProtocol.raise_error(buf)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 169, in raise_error
    raise errors.get_mysql_exception(errno,errmsg)
<span class="red">mysql.connector.errors.ProgrammingError: 1054: Unknown column 'msgSenderName' in 'field list'</span>

======================================================================
ERROR: test_ids (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 51, in setUp
    id = self.msgids[msg['message-id']] = maildb.store(msg)
  File "V:\workspace\EmailSearch\src\maildb.py", line 30, in store
    (message_id, dt, name, email, text))
  File "C:\python\lib\site-packages\mysql\connector\cursor.py", line 307, in execute
    res = self.db().protocol.cmd_query(stmt)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 137, in deco
    return func(*args, **kwargs)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 482, in cmd_query
    return self.handle_cmd_result(self._recv_packet())
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 175, in _recv_packet
    MySQLProtocol.raise_error(buf)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 169, in raise_error
    raise errors.get_mysql_exception(errno,errmsg)
<span class="red">mysql.connector.errors.ProgrammingError: 1054: Unknown column 'msgSenderName' in 'field list'</span>

======================================================================
ERROR: test_message_ids (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 51, in setUp
    id = self.msgids[msg['message-id']] = maildb.store(msg)
  File "V:\workspace\EmailSearch\src\maildb.py", line 30, in store
    (message_id, dt, name, email, text))
  File "C:\python\lib\site-packages\mysql\connector\cursor.py", line 307, in execute
    res = self.db().protocol.cmd_query(stmt)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 137, in deco
    return func(*args, **kwargs)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 482, in cmd_query
    return self.handle_cmd_result(self._recv_packet())
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 175, in _recv_packet
    MySQLProtocol.raise_error(buf)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 169, in raise_error
    raise errors.get_mysql_exception(errno,errmsg)
<span class="red">mysql.connector.errors.ProgrammingError: 1054: Unknown column 'msgSenderName' in 'field list'</span>

======================================================================
ERROR: test_not_empty (__main__.testRealEmail_traffic)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "V:\workspace\EmailSearch\src\testMaildb.py", line 51, in setUp
    id = self.msgids[msg['message-id']] = maildb.store(msg)
  File "V:\workspace\EmailSearch\src\maildb.py", line 28, in store
    (message_id, dt, name, email, text))
  File "C:\python\lib\site-packages\mysql\connector\cursor.py", line 307, in execute
    res = self.db().protocol.cmd_query(stmt)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 137, in deco
    return func(*args, **kwargs)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 482, in cmd_query
    return self.handle_cmd_result(self._recv_packet())
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 175, in _recv_packet
    MySQLProtocol.raise_error(buf)
  File "C:\python\lib\site-packages\mysql\connector\protocol.py", line 169, in raise_error
    raise errors.get_mysql_exception(errno,errmsg)
<span class="red">mysql.connector.errors.ProgrammingError: 1054: Unknown column 'msgSenderName' in 'field list'</span>

----------------------------------------------------------------------
Ran 4 tests in 0.171s

FAILED (errors=3)
</pre></div></div>
            
      <p>We need to update the test program and add the two more columns to the message table. 
          Since we're familiar with adding columns now, let's bypass writing tests for these.
          Modify <b>testMaildb.py</b> 
      as shown:</p>

<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>"""
Read in and parse email messages to verify readability.

NOTE: This test creates the message table, dropping any
previous version and should leave it empty. DANGER: this
test will delete any existing message table.
"""
from glob import glob
from email import message_from_string
import mysql.connector as msc
from database import login_info
import maildb
import unittest
import datetime
from email.utils import parsedate_tz, mktime_tz

conn = msc.Connect(**login_info)
curs = conn.cursor()

TBLDEF = """\
CREATE TABLE message (
     msgID INTEGER AUTO_INCREMENT PRIMARY KEY,
     msgMessageID VARCHAR(128),
     msgDate DATETIME,
<ins>     msgSenderName VARCHAR(128),
     msgSenderAddress VARCHAR(128),</ins>
     msgText LONGTEXT
) ENGINE = MYISAM"""
FILESPEC = "C:/PythonData/*.eml"

class testRealEmail_traffic(unittest.TestCase):
    def setUp(self):
        """
        Reads an arbitrary number of mail messages and
        stores them in a brand new messages table.
        
        DANGER: Any existing message table WILL be lost.
        """
        curs.execute("DROP TABLE IF EXISTS message")
        conn.commit()
        curs.execute(TBLDEF)
        conn.commit()
        files = glob(FILESPEC)
        self.msgids = {} # Keyed by message_id
        self.message_ids = {} # keyed by id
        self.msgdates = []
        self.rowcount = 0
        for f in files:
            ff = open(f)
            text = ff.read()
            msg = message_from_string(text)
            id = self.msgids[msg['message-id']] = maildb.store(msg)
            self.message_ids[id] = msg['message-id']
            date = msg['date']
            self.msgdates.append(datetime.datetime.fromtimestamp(mktime_tz(parsedate_tz(date))))
            self.rowcount += 1 # Assuming no duplicated Message-IDs

    def test_not_empty(self):
        """
        Verify that the setUp method actually created some messages.
        If it finds no files there will be no messages in the table,
        the loop bodies in the other tests will never run, and potential
        errors will never be discovered.
        """
        curs.execute("SELECT COUNT(*) FROM message")
        messagect = curs.fetchone()[0]
        self.assertGreater(messagect, 0, "Database message table is empty")
 
    def test_message_ids(self):
        """
        Verify that items retrieved by id have the correct Message-ID.
        """  
        for message_id in self.msgids.keys():
            id, msg = maildb.msg_by_id(self.msgids[message_id]) 
            self.assertEqual(msg['message-id'], message_id)
            self.assertEqual(id, self.msgids[message_id])

    def test_ids(self):
        """
        Verify that items retrieved by message_id have the correct Message-ID.
        """
        for id in self.message_ids.keys():
            id1, msg = maildb.msg_by_message_id(self.message_ids[id])
            self.assertEqual(msg['message-id'], self.message_ids[id])
            self.assertEqual(id, id1)

    def test_dates(self):
        """
        Verify that retrieving records between the minimum and maximum dates
        returns an appropriate number of records, and that each separate day
        shows one email for each sender.
        """
        mind = min(self.msgdates)
        mindate = datetime.date(mind.year, mind.month, mind.day)
        maxd = max(self.msgdates)
        maxdate = datetime.date(maxd.year, maxd.month, maxd.day)
        self.assertEqual(self.rowcount,
                         len(maildb.msgs<del>_by_date</del>(mindate=mindate,
                                         maxdate=maxdate)))

if __name__ == "__main__":
    unittest.main()
</pre></div></div>
            
      <p>Of course, we expected all tests to pass. And the <b>mlist1.py</b> program 
          that we wrote earlier still functions perfectly, even though new columns have been added to 
          the table since last you ran it: </p>
            
<div class="observeBox"><div class="observeTitle">OBSERVE: </div><div class="observe"><pre>....
----------------------------------------------------------------------
Ran 4 tests in 0.892s

OK
</pre></div></div>
        
  </div></div>
  <a name="s_06"></a><div id="s_06"><div class="subheading">Adding A GUI</div><div class="subheadingText">
            
      <p>Our tests give us some confidence that our email storage library is sound. How difficult would it 
          be to build a graphical user interface to use with it? Not too difficult if we use a basic 
          layout to prototype the program. </p>
            
      <p>In earlier lessons, we used the <b>tkinter</b> grid layout to produce quick interface layouts. This 
          is fineâ€”so long as when the final interface is produced, the widgets that 
          matter (the ones used by the methods) keep the same names. </p>
            
      <p>This particular application offers four search field entries: two for the minimum and maximum 
          dates, one for the email address, and one for the name. We'll place these with appropriate labels 
          on a four-by-two grid, with the labels right-justified and the entry widgets left-justified. We'll 
          add a button to trigger the search to the second column in the fifth row, and the final two rows 
          will hold a listbox and a text widget. </p>
            
      <p>In the <b>EmailSearch/src</b> folder, create <b>mailgui.py</b> as shown: </p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre><ins>from tkinter import *
from maildb import msgs
import datetime

class Application(Frame):

    def __init__(self, master=None):
        """
        Establish the window structure, leaving some widgets accessible
        as app instance variables.
        """
        Frame.__init__(self, master)
        self.master.rowconfigure(0, weight=1)
        self.master.columnconfigure(0, weight=1)
        self.grid(sticky=W+E+N+S)
        l0 = Label(self, text="Email Database Search", font=("Helvetica", 16))
        l0.grid(row=0, column=1, columnspan=2)
        l1 = Label(self, text="Not Before (yyyy-mm-dd):")
        l1.grid(row=1, column=1, sticky=E+N+S)
        self.mindate = Entry(self)
        self.mindate.grid(row=1, column=2, sticky=W+N+S)
        l2 = Label(self, text="Not After (yyyy-mm-dd):")
        l2.grid(row=2, column=1, sticky=E+N+S)
        self.maxdate = Entry(self)
        self.maxdate.grid(row=2, column=2, sticky=W+N+S)
        l3 = Label(self, text="Sender's E-mail Contains:")
        l3.grid(row=3, column=1, sticky=E+N+S)
        self.addsearch = Entry(self)
        self.addsearch.grid(row=3, column=2, sticky=W+N+S)
        l4 = Label(self, text="Sender's Name Contains:")
        l4.grid(row=4, column=1, sticky=E+N+S)
        self.namesearch = Entry(self)
        self.namesearch.grid(row=4, column=2, sticky=W+N+S)
        button = Button(self, text="Search")
        button.grid(row=5, column=2)
        self.msgsubs = Listbox(self, height=10, width=100)
        self.msgsubs.grid(row=8, column=1, columnspan=2)
        self.message = Text(self, width=100)
        self.message.grid(row=9, column=1, columnspan=2)
        
if __name__ == "__main__":
    
    root = Tk()
    app = Application(master=root)  
    app.mainloop()</ins>
</pre></div></div>
            
      <p><img src="./Email Search and Display_files/icon_run.png"> When you run this code, you see a GUI that looks like 
          thisâ€”as promised, ugly but functional: </p>
            
      <p></p><div class="c"><img src="./Email Search and Display_files/GUIOnly.png"></div><p></p>
      
      <p>With the interface rendering properly as a window on the screen, now we need to plug in the 
          "works." First, we'll add a search routine to run when the <b>Search</b> button is clicked. It should 
          perform a search and populate the Listbox with the subject lines of each message. </p>
            
      <p>The <b>maildb.msgs</b> search function does not require all arguments, but we want to be able 
          to search on all of them, we'll provide them all. We'll arrange for the value <b>None</b> to be presented 
          whenever the user's Entry is empty. </p>
            
      <p>Dates are just a little trickier. We'll add a simple conversion function, and require that the user 
          enters dates as "YYYY-MM-DD." It isn't particularly user-friendly to require such 
          closely-formatted entries, but we can improve that later if necessary. The function converts 
          those strings into a <b>datetime.date</b> object for passing to 
          <span class="darkgreen">maildb.msgs()</span>. </p>
            
      <p>The main addition is the <span class="darkgreen">search_mail()</span> method, which does all the necessary 
          preparation and finally calls <span class="darkgreen">maildb.msgs()</span> to retrieve the specified 
          messages and display the subject header value of each in a Listbox. We trigger the instance's  
          <span class="darkgreen">search_mail()</span> method by adding it as the <b>command</b> configuration 
          parameter to the Button's creation. The <span class="darkgreen">search_mail()</span> method is also called 
          at startup, before the window is displayed. Modify <b>mailgui.py</b> as shown: </p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>from tkinter import *
from maildb import msgs
import datetime

<ins>def get_date(s):
    """
    Assumes a date of form yyyy-mm-dd, returns a corresponding datetime.date.
    """
    syear = s[:4]
    smonth = s[5:7]
    sday = s[8:]
    return datetime.date(int(syear), int(smonth), int(sday))
</ins>
class Application(Frame):

    def __init__(self, master=None):
        """
        Establish the window structure, leaving some widgets accessible
        as app instance variables. <ins>Connect button clicks to search_mail
        method.</ins> 
        """
        Frame.__init__(self, master)
        self.master.rowconfigure(0, weight=1)
        self.master.columnconfigure(0, weight=1)
        self.grid(sticky=W+E+N+S)
        l0 = Label(self, text="Email Database Search", font=("Helvetica", 16))
        l0.grid(row=0, column=1, columnspan=2)
        l1 = Label(self, text="Not Before (yyyy-mm-dd):")
        l1.grid(row=1, column=1, sticky=E+N+S)
        self.mindate = Entry(self)
        self.mindate.grid(row=1, column=2, sticky=W+N+S)
        l2 = Label(self, text="Not After (yyyy-mm-dd):")
        l2.grid(row=2, column=1, sticky=E+N+S)
        self.maxdate = Entry(self)
        self.maxdate.grid(row=2, column=2, sticky=W+N+S)
        l3 = Label(self, text="Sender's E-mail Contains:")
        l3.grid(row=3, column=1, sticky=E+N+S)
        self.addsearch = Entry(self)
        self.addsearch.grid(row=3, column=2, sticky=W+N+S)
        l4 = Label(self, text="Sender's Name Contains:")
        l4.grid(row=4, column=1, sticky=E+N+S)
        self.namesearch = Entry(self)
        self.namesearch.grid(row=4, column=2, sticky=W+N+S)
        button = Button(self, text="Search"<ins>, command=self.search_mail</ins>)
        button.grid(row=5, column=2)
        self.msgsubs = Listbox(self, height=10, width=100)
        self.msgsubs.grid(row=8, column=1, columnspan=2)
        self.message = Text(self, width=100)
        self.message.grid(row=9, column=1, columnspan=2)
        
<ins>    def search_mail(self):
        """
        Take the database search parameters provided by the user
        (trying to make sense of the dates) and select the appropriate
        messages from the database, displaying the subject lines of the
        messages in a scrolling selection list.
        """
        mindate = self.mindate.get()
        if not mindate:
            mindate = None
        else:
            mindate = get_date(mindate)
        maxdate = self.maxdate.get()
        if not maxdate:
            maxdate = None
        else:
            maxdate = get_date(maxdate)
        addsearch = self.addsearch.get()
        if not addsearch:
            addsearch = None
        namesearch = self.namesearch.get()
        if not namesearch:
            namesearch = None
        self.msglist = msgs(mindate=mindate, maxdate=maxdate, addsearch=addsearch, namesearch=namesearch)
        self.msgsubs.delete(0, END)
        for pk, msg in self.msglist:
            self.msgsubs.insert(END, msg['subject'])
</ins>
if __name__ == "__main__":
    
    root = Tk()
    app = Application(master=root)  
<ins>    app.search_mail()              
</ins>    app.mainloop()
</pre></div></div>
            
      <p>Now we have a program that will list the subject lines of the messages that meet the search 
          criteria. By default, you'll see whatever content is in the database (which is usually 
          whatever was left by the last test in the messages table). So the window looks more or less the same 
          when you run it as it did before, except that you see messages listed in the Listbox. </p>
            
      <p></p><div class="c"><img src="./Email Search and Display_files/GUIList.png"></div><p></p>
            
      <p>The final step is to connect a double-click on a Listbox entry to display the content of that 
          message in the Text widget at the bottom of the window. Again, the code changes are fairly straightforward. 
          The required double-click event is bound to the new 
          <span class="darkgreen">display_mail()</span> method, and the method extracts the selection from the 
          Listbox and deletes any existing content from the Text widget. Then it inserts up to three headers, 
          followed by a blank line and the body of the 
          messages (unless it happens to be a multipart messageâ€”those are a little trickier to handle). 
          Modify <b>mailgui.py</b> as shown:</p>
            
<div class="listingBox"><div class="listingTitle">CODE TO TYPE:</div><div class="listing"><pre>from tkinter import *
from maildb import msgs
import datetime

def get_date(s):
    """
    Assumes a date of form yyyy-mm-dd, returns a corresponding datetime.date.
    """
    syear = s[:4]
    smonth = s[5:7]
    sday = s[8:]
    return datetime.date(int(syear), int(smonth), int(sday))

class Application(Frame):

    def __init__(self, master=None):
        """
        Establish the window structure, leaving some widgets accessible
        as app instance variables. Connect button clicks to search_mail
        method <ins>and subject double-clicks to display_mail method</ins>.
        """
        Frame.__init__(self, master)
        self.master.rowconfigure(0, weight=1)
        self.master.columnconfigure(0, weight=1)
        self.grid(sticky=W+E+N+S)
        l0 = Label(self, text="Email Database Search", font=("Helvetica", 16))
        l0.grid(row=0, column=1, columnspan=2)
        l1 = Label(self, text="Not Before (yyyy-mm-dd):")
        l1.grid(row=1, column=1, sticky=E+N+S)
        self.mindate = Entry(self)
        self.mindate.grid(row=1, column=2, sticky=W+N+S)
        l2 = Label(self, text="Not After (yyyy-mm-dd):")
        l2.grid(row=2, column=1, sticky=E+N+S)
        self.maxdate = Entry(self)
        self.maxdate.grid(row=2, column=2, sticky=W+N+S)
        l3 = Label(self, text="Sender's E-mail Contains:")
        l3.grid(row=3, column=1, sticky=E+N+S)
        self.addsearch = Entry(self)
        self.addsearch.grid(row=3, column=2, sticky=W+N+S)
        l4 = Label(self, text="Sender's Name Contains:")
        l4.grid(row=4, column=1, sticky=E+N+S)
        self.namesearch = Entry(self)
        self.namesearch.grid(row=4, column=2, sticky=W+N+S)
        button = Button(self, text="Search", command=self.search_mail)
        button.grid(row=5, column=2)
        self.msgsubs = Listbox(self, height=10, width=100)
        self.msgsubs.grid(row=8, column=1, columnspan=2)
        <ins>self.msgsubs.bind("&lt;Double-Button-1&gt;", self.display_mail)</ins>
        self.message = Text(self, width=100)
        self.message.grid(row=9, column=1, columnspan=2)
        
    def search_mail(self):
        """
        Take the database search parameters provided by the user
        (trying to make sense of the dates) and select the appropriate
        messages from the database, displaying the subject lines of the
        messages in a scrolling selection list.
        """
        mindate = self.mindate.get()
        if not mindate:
            mindate = None
        else:
            mindate = get_date(mindate)
        maxdate = self.maxdate.get()
        if not maxdate:
            maxdate = None
        else:
            maxdate = get_date(maxdate)
        addsearch = self.addsearch.get()
        if not addsearch:
            addsearch = None
        namesearch = self.namesearch.get()
        if not namesearch:
            namesearch = None
        self.msglist = msgs(mindate=mindate, maxdate=maxdate, addsearch=addsearch, namesearch=namesearch)
        self.msgsubs.delete(0, END)
        for pk, msg in self.msglist:
            self.msgsubs.insert(END, msg['subject'])

<ins>    def display_mail(self, event):
        """
        Display the message corresponding to the subject line that the
        user just clicked on.
        """ 
        indexes = self.msgsubs.curselection()
        if len(indexes) != 1:
            return
        self.message.delete(1.0, END)
        pk, msg = self.msglist[int(indexes[0])]
        for header_name in "Subject", "Date", "From":
            hdr = msg[header_name]
            if hdr:
                self.message.insert(INSERT, "{0}: {1}\n".format(header_name, hdr))
        self.message.insert(END, "\n")
        if msg.is_multipart():
            self.message.insert(END, "MULTIPART MESSAGE - SORRY!")
        self.message.insert(END, msg.get_payload())
</ins>
if __name__ == "__main__":
    
    root = Tk()
    app = Application(master=root)  
    app.search_mail()              
    app.mainloop()
</pre></div></div>
            
      <p><img src="./Email Search and Display_files/icon_run.png"> When you run this modified code, you see the final 
          (but not necessarily complete) form of our GUI-based mail retrieval program. It searches messages 
          by date range, sender name, and email address, and allows you to view any message in the search 
          results by double-clicking the message subject. This sort of code might be considered "alpha 
          quality"â€”it can be released for testing purposes, but it's not quite ready for prime time. </p>
            
      <p></p><div class="c"><img src="./Email Search and Display_files/GUIAll.png"></div><p></p>
            
      <p>The appearance of the interface could be improved, but the program's basic design is sound. 
          The program is 
          constructed plainly, and we can see how to extend it in various ways. </p>
            
      <p>For example, if you wanted to add subject search features, it's pretty clear  
          that you'd need to add an <b>msgSubject</b> column to the message table and therefore to the 
          logic of <span class="darkgreen">maildb.store()</span>. The interface to 
          <span class="darkgreen">maildb.msgs()</span> would need to be augmented by a <b>subjectsearch</b> argument, and
          the GUI would need to add another Entry element to capture the user's search string. Fortunately, this program 
          is logically organized, and you should be able to proceed with confidence. </p>
        
  </div></div>
  <a name="s_07"></a><div id="s_07"><div class="subheading">Documentation</div><div class="subheadingText">
            
      <p>Open a new pydev console, select the <b>Console</b> tab, and maximize the console so that you can 
          see the output. Enter the commands below as shown:</p> 
                
<div class="interactiveBox"><div class="interactiveTitle">INTERACTIVE SESSION:</div><div class="interactive"><pre>&gt;&gt;&gt; <ins>import maildb</ins>
&gt;&gt;&gt; <ins>help(maildb)</ins>                    
</pre></div></div>
            
      <p>The Python help system uses all of the docstrings you've put into your code to produce a 
          brief description of your <b>maildb</b> module. </p>
            
      <p></p><div class="c"><img src="./Email Search and Display_files/HelpDocs.png"></div><p></p>
      
  </div></div>
  
     <p>Congratulations! Your hard work is really paying off. You've powered through all of the challenges we've thrown at you 
        and arrived at the 
         finish line of this second O'Reilly School of Technology Python course.  
         Your command of the language is astounding! You can integrate databases 
         and graphical user interfaces, and you're
         prepared to explore the bigger Python landscape. Now let's dazzle your instructor and 
         put those skills to work in your final project! 
         It's been a real pleasure working with you. 
         See you in the next course!</p>
    
 </div>
<div class="footer"><div id="timeSurvey"><iframe frameborder="0" width="400" height="150" src="./Email Search and Display_files/time_survey.html"></iframe></div>				
				Copyright Â© 1998-2014 O'Reilly Media, Inc.<br><img src="./Email Search and Display_files/cclicense.png"><br>
				This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
				See <a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a> 
				for more information.
				</div><iframe id="t" width="1" height="1" border="0" style="display:none" src="about:blank"></iframe><script language="javascript">bodyLoaded();</script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44720547-1', 'oreillyschool.com');
  ga('send', 'pageview');
</script></body></html>